{"version":3,"file":"iro-core.modern.js","sources":["../src/color.ts","../src/slider.ts","../src/wheel.ts","../src/triangleWheel.ts","../src/hueRing.ts","../src/triangle.ts","../src/box.ts","../src/util.ts","../src/css.ts","../src/colorPickerOptions.ts"],"sourcesContent":["// Some regular expressions for rgb() and hsl() Colors are borrowed from tinyColor\n// https://github.com/bgrins/TinyColor\n// Kelvin temperature math borrowed from Neil Barlett's implementation\n// from https://github.com/neilbartlett/color-temperature\n\n// https://www.w3.org/TR/css3-values/#integers\nconst CSS_INTEGER = '[-\\\\+]?\\\\d+%?';\n// http://www.w3.org/TR/css3-values/#number-value\nconst CSS_NUMBER = '[-\\\\+]?\\\\d*\\\\.\\\\d+%?';\n// Allow positive/negative integer/number. Don't capture the either/or, just the entire outcome\nconst CSS_UNIT = '(?:' + CSS_NUMBER + ')|(?:' + CSS_INTEGER + ')';\n\n// Parse function params\n// Parens and commas are optional, and this also allows for whitespace between numbers\nconst PERMISSIVE_MATCH_3 = '[\\\\s|\\\\(]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')\\\\s*\\\\)?';\nconst PERMISSIVE_MATCH_4 = '[\\\\s|\\\\(]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')\\\\s*\\\\)?';\n\n// Regex patterns for functional color strings\nconst REGEX_FUNCTIONAL_RGB = new RegExp('rgb' + PERMISSIVE_MATCH_3);\nconst REGEX_FUNCTIONAL_RGBA = new RegExp('rgba' + PERMISSIVE_MATCH_4);\nconst REGEX_FUNCTIONAL_HSL = new RegExp('hsl' + PERMISSIVE_MATCH_3);\nconst REGEX_FUNCTIONAL_HSLA = new RegExp('hsla' + PERMISSIVE_MATCH_4);\n\n// Color string parsing regex\nconst HEX_START = '^(?:#?|0x?)';\nconst HEX_INT_SINGLE = '([0-9a-fA-F]{1})';\nconst HEX_INT_DOUBLE = '([0-9a-fA-F]{2})';\nconst REGEX_HEX_3 = new RegExp(HEX_START + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + '$');\nconst REGEX_HEX_4 = new RegExp(HEX_START + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + '$');\nconst REGEX_HEX_6 = new RegExp(HEX_START + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + '$');\nconst REGEX_HEX_8 = new RegExp(HEX_START + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + '$');\n\n// Kelvin temperature bounds\nconst KELVIN_MIN = 2000;\nconst KELVIN_MAX = 40000;\n\n// Math shorthands\nconst { log, round, floor } = Math;\n\n/**\n * @desc Clamp a number between a min and max value\n * @param num - input value\n * @param min - min allowed value\n * @param max - max allowed value\n */\nfunction clamp(num: number, min: number, max: number): number {\n  return Math.min(Math.max(num, min), max)\n}\n\n/**\n * @desc Parse a css unit string - either regular int or a percentage number\n * @param str - css unit string\n * @param max - max unit value, used for calculating percentages\n */\nfunction parseUnit(str: string, max: number): number {\n  const isPercentage = str.indexOf('%') > -1;\n  const num = parseFloat(str);\n  return isPercentage ? (max / 100) * num : num;\n}\n\n/**\n * @desc Parse hex str to an int\n * @param str - hex string to parse\n */\nfunction parseHexInt(str: string): number {\n  return parseInt(str, 16);\n}\n\n/**\n * @desc Convert nunber into to 2-digit hex\n * @param int - number to convert\n */\nfunction intToHex(int: number): string {\n  return int.toString(16).padStart(2, '0');\n}\n\nexport interface ColorChanges {\n  h: boolean;\n  s: boolean;\n  v: boolean;\n  a: boolean;\n}\n\n// all hsv color channels are optional by design\nexport interface HsvColor {\n  h?: number;\n  s?: number;\n  v?: number;\n  a?: number;\n}\n\nexport interface RgbColor {\n  r: number;\n  g: number;\n  b: number;\n  a?: number;\n}\n\nexport interface HslColor {\n  h: number;\n  s: number;\n  l: number;\n  a?: number;\n}\n\nexport interface KelvinColor {\n  kelvin: number;\n}\n\nexport type IroColorValue = IroColor | HsvColor | RgbColor | HslColor | KelvinColor | string;\n\nexport class IroColor {\n  // internal color value storage\n  private $: HsvColor;\n  private onChange: Function;\n  private initialValue: HsvColor;\n\n  public index: number;\n\n  /**\n    * @constructor Color object\n    * @param value - initial color value\n  */\n  constructor(value?: IroColorValue, onChange?: Function) {\n    // The default Color value\n    this.$ = {h: 0, s: 0, v: 0, a: 1};\n    if (value) this.set(value);\n    // The watch callback function for this Color will be stored here\n    this.onChange = onChange;\n    this.initialValue = { ...this.$ }; // copy initial value\n  }\n\n  /**\n    * @desc Set the Color from any valid value\n    * @param value - new color value\n  */\n  public set(value: IroColorValue) {\n    if (typeof value === 'string') {\n      if (/^(?:#?|0x?)[0-9a-fA-F]{3,8}$/.test(value as string)) {\n        this.hexString = value as string;\n      }\n      else if (/^rgba?/.test(value as string)) {\n        this.rgbString = value as string;\n      }\n      else if (/^hsla?/.test(value as string)) {\n        this.hslString = value as string;\n      }\n    }\n    else if (typeof value === 'object') {\n      if (value instanceof IroColor) {\n        this.hsv = value.hsv;\n      }\n      else if ('r' in value && 'g' in value && 'b' in value) {\n        this.rgb = value;\n      }\n      else if ('h' in value && 's' in value && 'v' in value) {\n        this.hsv = value;\n      }\n      else if ('h' in value && 's' in value && 'l' in value) {\n        this.hsl = value;\n      }\n      else if ('kelvin' in value) {\n        this.kelvin = value.kelvin;\n      }\n    }\n    else {\n      throw new Error('Invalid color value');\n    }\n  }\n\n  /**\n    * @desc Shortcut to set a specific channel value\n    * @param format - hsv | hsl | rgb\n    * @param channel - individual channel to set, for example if model = hsl, chanel = h | s | l\n    * @param value - new value for the channel\n  */\n  public setChannel(format: string, channel: string, value: number) {\n    this[format] = {...this[format], [channel]: value};\n  }\n\n  /**\n   * @desc Reset color back to its initial value\n   */\n  public reset() {\n    this.hsva = this.initialValue;\n  }\n\n  /**\n    * @desc make new Color instance with the same value as this one\n  */\n  public clone() {\n    return new IroColor(this);\n  }\n\n  /**\n   * @desc remove color onChange\n   */\n  public unbind() {\n    this.onChange = undefined;\n  }\n\n  /**\n    * @desc Convert hsv object to rgb\n    * @param hsv - hsv color object\n  */\n  public static hsvToRgb(hsv: HsvColor): RgbColor {\n    const h = hsv.h / 60;\n    const s = hsv.s / 100;\n    const v = hsv.v / 100;\n    const i = floor(h);\n    const f = h - i;\n    const p = v * (1 - s);\n    const q = v * (1 - f * s);\n    const t = v * (1 - (1 - f) * s);\n    const mod = i % 6;\n    const r = [v, q, p, p, t, v][mod];\n    const g = [t, v, v, q, p, p][mod];\n    const b = [p, p, t, v, v, q][mod];\n    return {\n      r: clamp(r * 255, 0, 255), \n      g: clamp(g * 255, 0, 255), \n      b: clamp(b * 255, 0, 255)\n    };\n  }\n\n  /**\n    * @desc Convert rgb object to hsv\n    * @param rgb - rgb object\n  */\n  public static rgbToHsv(rgb: RgbColor): HsvColor {\n    const r = rgb.r / 255;\n    const g = rgb.g / 255;\n    const b = rgb.b / 255;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const delta = max - min;\n    let hue = 0;\n    let value = max;\n    let saturation = max === 0 ? 0 : delta / max;\n    switch (max) {\n      case min: \n        hue = 0; // achromatic\n        break;\n      case r: \n        hue = (g - b) / delta + (g < b ? 6 : 0);\n        break;\n      case g: \n        hue = (b - r) / delta + 2;\n        break;\n      case b:\n        hue = (r - g) / delta + 4;\n        break;\n    }\n    return {\n      h: (hue * 60) % 360,\n      s: clamp(saturation * 100, 0, 100),\n      v: clamp(value * 100, 0, 100)\n    }\n  }\n\n  /**\n    * @desc Convert hsv object to hsl\n    * @param hsv - hsv object\n  */\n  public static hsvToHsl(hsv: HsvColor): HslColor {\n    const s = hsv.s / 100;\n    const v = hsv.v / 100;\n    const l = (2 - s) * v;\n    const divisor = l <= 1 ? l : (2 - l);\n    // Avoid division by zero when lightness is close to zero\n    const saturation = divisor < 1e-9 ? 0 : (s * v) / divisor;\n    return {\n      h: hsv.h,\n      s: clamp(saturation * 100, 0, 100),\n      l: clamp(l * 50, 0, 100)\n    };\n  }\n\n  /**\n    * @desc Convert hsl object to hsv\n    * @param hsl - hsl object\n  */\n  public static hslToHsv(hsl: HslColor): HsvColor {\n    const l = hsl.l * 2;\n    const s = (hsl.s * ((l <= 100) ? l : 200 - l)) / 100;\n    // Avoid division by zero when l + s is near 0\n    const saturation = (l + s < 1e-9) ? 0 : (2 * s) / (l + s);\n    return {\n      h: hsl.h,\n      s: clamp(saturation * 100, 0, 100),\n      v: clamp((l + s) / 2, 0, 100)\n    };\n  }\n\n  /**\n    * @desc Convert a kelvin temperature to an approx, RGB value\n    * @param kelvin - kelvin temperature\n  */\n  public static kelvinToRgb(kelvin: number): RgbColor {\n    const temp = kelvin / 100;\n    let r, g, b;\n    if (temp < 66) {\n      r = 255\n      g = -155.25485562709179 - 0.44596950469579133 * (g = temp-2) + 104.49216199393888 * log(g)\n      b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp-10) + 115.67994401066147 * log(b)\n    } else {\n      r = 351.97690566805693 + 0.114206453784165 * (r = temp-55) - 40.25366309332127 * log(r)\n      g = 325.4494125711974 + 0.07943456536662342 * (g = temp-50) - 28.0852963507957 * log(g)\n      b = 255\n    }\n    return {\n      r: clamp(floor(r), 0, 255),\n      g: clamp(floor(g), 0, 255),\n      b: clamp(floor(b), 0, 255)\n    };\n  }\n\n   /**\n    * @desc Convert an RGB color to an approximate kelvin temperature\n    * @param kelvin - kelvin temperature\n  */\n  public static rgbToKelvin(rgb: RgbColor): number {\n    const { r, g, b } = rgb;\n    const eps = 0.4;\n    let minTemp = KELVIN_MIN;\n    let maxTemp = KELVIN_MAX;\n    let temp;\n    while (maxTemp - minTemp > eps) {\n      temp = (maxTemp + minTemp) * 0.5;\n      const rgb = IroColor.kelvinToRgb(temp);\n      if ((rgb.b / rgb.r) >= (b / r)) {\n        maxTemp = temp;\n      } else {\n        minTemp = temp;\n      }\n    }\n    return temp;\n  }\n\n  public get hsv(): HsvColor {\n    // value is cloned to allow changes to be made to the values before passing them back\n    const value = this.$;\n    return {h: value.h, s: value.s, v: value.v};\n  }\n\n  public set hsv(newValue: HsvColor) {\n    const oldValue = this.$;\n\n    newValue = { ...oldValue, ...newValue };\n    // If this Color is being watched for changes we need to compare the new and old values to check the difference\n    // Otherwise we can just be lazy\n    if (this.onChange) {\n      // Compute changed values\n      let changes: ColorChanges = {\n        h: false,\n        v: false,\n        s: false,\n        a: false,\n      };\n\n      for (let key in oldValue) {\n        changes[key] = newValue[key] != oldValue[key]\n      };\n      // Update the old value\n      this.$ = newValue;\n      // If the value has changed, call hook callback\n      if (changes.h || changes.s || changes.v || changes.a) this.onChange(this, changes);\n    } else {\n      this.$ = newValue;\n    }\n  }\n\n  public get hsva(): HsvColor {\n    return {...this.$};\n  }\n\n  public set hsva(value: HsvColor) {\n    this.hsv = value;\n  }\n\n  public get hue(): number {\n    return this.$.h;\n  }\n\n  public set hue(value: number) {\n    this.hsv = { h: value };\n  }\n\n  public get saturation(): number {\n    return this.$.s;\n  }\n\n  public set saturation(value: number) {\n    this.hsv = { s: value };\n  }\n\n  public get value(): number {\n    return this.$.v;\n  }\n\n  public set value(value: number) {\n    this.hsv = { v: value };\n  }\n\n  public get alpha(): number {\n    return this.$.a;\n  }\n\n  public set alpha(value: number) {\n    this.hsv = { ...this.hsv, a: value };\n  }\n\n  public get kelvin(): number {\n    return IroColor.rgbToKelvin(this.rgb);\n  }\n\n  public set kelvin(value: number) {\n    this.rgb = IroColor.kelvinToRgb(value);\n  }\n\n  public get red(): number {\n    const rgb = this.rgb;\n    return rgb.r;\n  }\n\n  public set red(value: number) {\n    this.rgb = { ...this.rgb, r: value };\n  }\n\n  public get green(): number {\n    const rgb = this.rgb;\n    return rgb.g;\n  }\n\n  public set green(value: number) {\n    this.rgb = { ...this.rgb, g: value };\n  }\n\n  public get blue(): number {\n    const rgb = this.rgb;\n    return rgb.b;\n  }\n\n  public set blue(value: number) {\n    this.rgb = { ...this.rgb, b: value };\n  }\n\n  public get rgb(): RgbColor {\n    const {r, g, b} = IroColor.hsvToRgb(this.$);\n    return {\n      r: round(r),\n      g: round(g),\n      b: round(b),\n    };\n  }\n\n  public set rgb(value: RgbColor) {\n    this.hsv = {\n      ...IroColor.rgbToHsv(value), \n      a: (value.a === undefined) ? 1 : value.a\n    };\n  }\n\n  public get rgba(): RgbColor {\n    return { ...this.rgb, a: this.alpha };\n  }\n\n  public set rgba(value: RgbColor) {\n    this.rgb = value;\n  }\n\n  public get hsl(): HslColor {\n    const {h, s, l} = IroColor.hsvToHsl(this.$);\n    return {\n      h: round(h),\n      s: round(s),\n      l: round(l),\n    };\n  }\n\n  public set hsl(value: HslColor) {\n    this.hsv = {\n      ...IroColor.hslToHsv(value), \n      a: (value.a === undefined) ? 1 : value.a\n    };\n  }\n\n  public get hsla(): HslColor {\n    return { ...this.hsl, a: this.alpha };\n  }\n\n  public set hsla(value: HslColor) {\n    this.hsl = value;\n  }\n\n  public get rgbString(): string {\n    const rgb = this.rgb;\n    return `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;\n  }\n\n  public set rgbString(value: string) {\n    let match;\n    let r, g, b, a = 1;\n    if (match = REGEX_FUNCTIONAL_RGB.exec(value)) {\n      r = parseUnit(match[1], 255);\n      g = parseUnit(match[2], 255);\n      b = parseUnit(match[3], 255);\n    }\n    else if (match = REGEX_FUNCTIONAL_RGBA.exec(value)) {\n      r = parseUnit(match[1], 255);\n      g = parseUnit(match[2], 255);\n      b = parseUnit(match[3], 255);\n      a = parseUnit(match[4], 1);\n    }\n    if (match) {\n      this.rgb = {r, g, b, a};\n    } \n    else {\n      throw new Error('Invalid rgb string');\n    }\n  }\n\n  public get rgbaString(): string {\n    const rgba = this.rgba;\n    return `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;\n  }\n\n  public set rgbaString(value: string) {\n    this.rgbString = value;\n  }\n\n  public get hexString(): string {\n    const rgb = this.rgb;\n    return `#${ intToHex(rgb.r) }${ intToHex(rgb.g) }${ intToHex(rgb.b) }`;\n  }\n\n  public set hexString(value: string) {\n    let match;\n    let r, g, b, a = 255;\n    if (match = REGEX_HEX_3.exec(value)) {\n      r = parseHexInt(match[1]) * 17;\n      g = parseHexInt(match[2]) * 17;\n      b = parseHexInt(match[3]) * 17;\n    }\n    else if (match = REGEX_HEX_4.exec(value)) {\n      r = parseHexInt(match[1]) * 17;\n      g = parseHexInt(match[2]) * 17;\n      b = parseHexInt(match[3]) * 17;\n      a = parseHexInt(match[4]) * 17;\n    }\n    else if (match = REGEX_HEX_6.exec(value)) {\n      r = parseHexInt(match[1]);\n      g = parseHexInt(match[2]);\n      b = parseHexInt(match[3]);\n    }\n    else if (match = REGEX_HEX_8.exec(value)) {\n      r = parseHexInt(match[1]);\n      g = parseHexInt(match[2]);\n      b = parseHexInt(match[3]);\n      a = parseHexInt(match[4]);\n    }\n    if (match) {\n      this.rgb = {r, g, b, a: a / 255};\n    }\n    else {\n      throw new Error('Invalid hex string');\n    }\n  }\n\n  public get hex8String(): string {\n    const rgba = this.rgba;\n    return `#${intToHex(rgba.r)}${intToHex(rgba.g)}${intToHex(rgba.b)}${intToHex(floor(rgba.a * 255))}`;\n  }\n\n  public set hex8String(value: string) {\n    this.hexString = value;\n  }\n\n  public get hslString(): string {\n    const hsl = this.hsl;\n    return `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`;\n  }\n\n  public set hslString(value: string) {\n    let match;\n    let h, s, l, a = 1;\n    if (match = REGEX_FUNCTIONAL_HSL.exec(value)) {\n      h = parseUnit(match[1], 360);\n      s = parseUnit(match[2], 100);\n      l = parseUnit(match[3], 100);\n    }\n    else if (match = REGEX_FUNCTIONAL_HSLA.exec(value)) {\n      h = parseUnit(match[1], 360);\n      s = parseUnit(match[2], 100);\n      l = parseUnit(match[3], 100);\n      a = parseUnit(match[4], 1);\n    }\n    if (match) {\n      this.hsl = {h, s, l, a};\n    } \n    else {\n      throw new Error('Invalid hsl string');\n    }\n  }\n\n  public get hslaString(): string {\n    const hsla = this.hsla;\n    return `hsl(${hsla.h}, ${hsla.s}%, ${hsla.l}%, ${hsla.a})`;\n  }\n\n  public set hslaString(value: string) {\n    this.hslString = value;\n  }\n}","import { IroColor } from './color';\nimport { CssGradientStops } from './css';\nimport { IroColorPickerOptions } from './colorPickerOptions';\n\nexport type SliderShape = 'bar' | 'circle' | '';\nexport type SliderType = 'red' | 'green' | 'blue' |'alpha' | 'hue' | 'saturation' | 'value' | 'kelvin' | '';\n\nexport interface SliderOptions extends IroColorPickerOptions {\n  color: IroColor;\n  sliderShape: SliderShape;\n  sliderType: SliderType;\n  minTemperature: number;\n  maxTemperature: number;\n}\n\nexport const sliderDefaultOptions = {\n  sliderShape: 'bar',\n  sliderType: 'value',\n  minTemperature: 2200,\n  maxTemperature: 11000\n}\n\n/**\n * @desc Get the CSS styles for the slider root\n * @param props - slider props\n */\nexport function getSliderStyles(props: Partial<SliderOptions>) {\n  return {\n    [props.layoutDirection === 'horizontal' ? 'marginLeft' : 'marginTop']: props.sliderMargin\n  }\n}\n\n/**\n * @desc Get the bounding dimensions of the slider\n * @param props - slider props\n */\nexport function getSliderDimensions(props: Partial<SliderOptions>) {\n  let { width, sliderSize: sliderSize, borderWidth, handleRadius, padding, sliderShape } = props;\n  const ishorizontal = props.layoutDirection === 'horizontal';\n  // automatically calculate sliderSize if its not defined\n  sliderSize = sliderSize ?? padding * 2 + handleRadius * 2;\n  if (sliderShape === 'circle') {\n    return {\n      handleStart: props.padding + props.handleRadius,\n      handleRange: width - padding * 2 - handleRadius * 2,\n      width: width,\n      height: width,\n      cx: width / 2,\n      cy: width / 2,\n      radius: width / 2 - borderWidth / 2\n    }\n  } else {\n    return {\n      handleStart: sliderSize / 2,\n      handleRange: width - sliderSize,\n      radius: sliderSize / 2,\n      x: 0,\n      y: 0,\n      width: ishorizontal ? sliderSize : width,\n      height: ishorizontal ? width : sliderSize,\n    }\n  }\n}\n\n/**\n * @desc Get the current slider value for a given color, as a percentage\n * @param props - slider props\n * @param color\n */\nexport function getCurrentSliderValue(props: Partial<SliderOptions>, color: IroColor) {\n  const hsva = color.hsva;\n  const rgb = color.rgb;\n\n  switch (props.sliderType) {\n    case 'red':\n      return rgb.r / 2.55;\n    case 'green':\n      return rgb.g / 2.55;\n    case 'blue':\n      return rgb.b / 2.55;\n    case 'alpha':\n      return hsva.a * 100;\n    case 'kelvin':\n      const { minTemperature, maxTemperature } = props;\n      const temperatureRange = maxTemperature - minTemperature;\n      const percent = ((color.kelvin - minTemperature) / temperatureRange) * 100;\n      // clmap percentage\n      return Math.max(0, Math.min(percent, 100));\n    case 'hue':\n      return hsva.h /= 3.6;\n    case 'saturation':\n      return hsva.s;\n    case 'value':\n    default:\n      return hsva.v;\n  }\n}\n\n/**\n * @desc Get the current slider value from user input\n * @param props - slider props\n * @param x - global input x position\n * @param y - global input y position\n */\nexport function getSliderValueFromInput(props: Partial<SliderOptions>, x: number, y: number) {\n  const { handleRange, handleStart } = getSliderDimensions(props);\n  let handlePos;\n  if (props.layoutDirection === 'horizontal') {\n    handlePos = -1 * y + handleRange + handleStart;\n  } else {\n    handlePos = x - handleStart;\n  }\n  // clamp handle position\n  handlePos = Math.max(Math.min(handlePos, handleRange), 0);\n  const percent = Math.round((100 / handleRange) * handlePos);\n  switch (props.sliderType) {\n    case 'kelvin':\n      const { minTemperature, maxTemperature } = props;\n      const temperatureRange = maxTemperature - minTemperature;\n      return minTemperature + temperatureRange * (percent / 100);\n    case 'alpha':\n      return percent / 100;\n    case 'hue':\n      return percent * 3.6;\n    case 'red':\n    case 'blue':\n    case 'green':\n      return percent * 2.55;\n    default:\n      return percent;\n  }\n}\n\n/**\n * @desc Get the current handle position for a given color\n * @param props - slider props\n * @param color\n */\nexport function getSliderHandlePosition(props: Partial<SliderOptions>, color: IroColor) {\n  const { width, height, handleRange, handleStart } = getSliderDimensions(props);\n  const ishorizontal = props.layoutDirection === 'horizontal';\n  const sliderValue = getCurrentSliderValue(props, color);\n  const midPoint = ishorizontal ? width / 2 : height / 2;\n  let handlePos = handleStart + (sliderValue / 100) * handleRange;\n  if (ishorizontal) {\n    handlePos = -1 * handlePos + handleRange + handleStart * 2;\n  } \n  return {\n    x: ishorizontal ? midPoint : handlePos, \n    y: ishorizontal ? handlePos : midPoint\n  };\n}\n\n/**\n * @desc Get the gradient stops for a slider\n * @param props - slider props\n * @param color\n */\nexport function getSliderGradient(props: Partial<SliderOptions>, color: IroColor): CssGradientStops {\n  const hsv = color.hsv;\n  const rgb = color.rgb;\n\n  switch (props.sliderType) {\n    case 'red':\n      return [\n        [0, `rgb(${ 0 },${ rgb.g },${ rgb.b })`],\n        [100, `rgb(${ 255 },${ rgb.g },${ rgb.b })`],\n      ];\n    case 'green':\n      return [\n        [0, `rgb(${ rgb.r },${ 0 },${ rgb.b })`],\n        [100, `rgb(${ rgb.r },${ 255 },${ rgb.b })`],\n      ];\n    case 'blue':\n      return [\n        [0, `rgb(${ rgb.r },${ rgb.g },${ 0 })`],\n        [100, `rgb(${ rgb.r },${ rgb.g },${ 255 })`],\n      ];\n    case 'alpha':\n      return [\n        [0, `rgba(${ rgb.r },${ rgb.g },${ rgb.b },0)`],\n        [100, `rgb(${ rgb.r },${ rgb.g },${ rgb.b })`],\n      ];\n    case 'kelvin':\n      const stops = [];\n      const min = props.minTemperature;\n      const max = props.maxTemperature;\n      const numStops = 8;\n      const range = max - min;\n      for (let kelvin = min, stop = 0; kelvin < max; kelvin += range / numStops, stop += 1) {\n        const { r, g, b } = IroColor.kelvinToRgb(kelvin);\n        stops.push([ 100 / numStops * stop, `rgb(${r},${g},${b})` ]);\n      }\n      return stops;\n    case 'hue':\n      return [\n        [0,      '#f00'],\n        [16.666, '#ff0'],\n        [33.333, '#0f0'],\n        [50,     '#0ff'],\n        [66.666, '#00f'],\n        [83.333, '#f0f'],\n        [100,    '#f00'],\n      ];\n    case 'saturation':\n      const noSat = IroColor.hsvToHsl({h: hsv.h, s: 0, v: hsv.v});\n      const fullSat = IroColor.hsvToHsl({h: hsv.h, s: 100, v: hsv.v});\n      return [\n        [0, `hsl(${noSat.h},${noSat.s}%,${noSat.l}%)`],\n        [100, `hsl(${fullSat.h},${fullSat.s}%,${fullSat.l}%)`]\n      ];\n    case 'value':\n    default:\n      const hsl = IroColor.hsvToHsl({h: hsv.h, s: hsv.s, v: 100});\n      return [\n        [0, '#000'],\n        [100, `hsl(${hsl.h},${hsl.s}%,${hsl.l}%)`]\n      ];\n  }\n}\n\n/**\n * @desc Get the gradient coords for a slider\n * @param props - slider props\n */\nexport function getSliderGradientCoords(props: Partial<SliderOptions>) {\n  const ishorizontal = props.layoutDirection === 'horizontal';\n  return {\n    x1: '0%',\n    y1: ishorizontal ? '100%' : '0%',\n    x2: ishorizontal ? '0%' : '100%',\n    y2: '0%'\n  }\n}","import { IroColorPickerOptions } from './colorPickerOptions';\nimport { IroColor, IroColorValue } from './color';\n\nexport interface WheelProps extends IroColorPickerOptions {\n  color: IroColor;\n}\n\nconst TAU = Math.PI * 2;\n\n// javascript's modulo operator doesn't produce positive numbers with negative input\n// https://dev.to/maurobringolf/a-neat-trick-to-compute-modulo-of-negative-numbers-111e\nconst mod = (a: number, n: number) => (a % n + n) % n;\n\n// distance between points (x, y) and (0, 0)\nconst dist = (x: number, y: number) => Math.sqrt(x * x + y * y);\n\n/**\n * @param props - wheel props\n * @internal\n */\nfunction getHandleRange(props: Partial<WheelProps>) {\n  return props.width / 2 - props.padding - props.handleRadius - props.borderWidth;\n}\n\n/**\n * Returns true if point (x, y) lands inside the wheel\n * @param props - wheel props\n * @param x \n * @param y \n */\nexport function isInputInsideWheel(props: Partial<WheelProps>, x: number, y: number) {\n  const { cx, cy } = getWheelDimensions(props);\n  const r = props.width / 2;\n  return dist(cx - x, cy - y) < r;\n}\n\n/**\n * @desc Get the point as the center of the wheel\n * @param props - wheel props\n */\nexport function getWheelDimensions(props: Partial<WheelProps>) {\n  const r = props.width / 2;\n  return {\n    width: props.width,\n    radius: r - props.borderWidth,\n    cx: r,\n    cy: r\n  };\n}\n\n/**\n * @desc Translate an angle according to wheelAngle and wheelDirection\n * @param props - wheel props\n * @param angle - input angle\n */\nexport function translateWheelAngle(props: Partial<WheelProps>, angle: number, invert?: boolean) {\n  const wheelAngle = props.wheelAngle;\n  const wheelDirection = props.wheelDirection\n  // inverted and clockwisee\n  if (invert && wheelDirection === 'clockwise')\n    angle = wheelAngle + angle;\n  // clockwise (input handling)\n  else if (wheelDirection === 'clockwise')\n    angle = (360 - wheelAngle) + angle;\n  // inverted and anticlockwise\n  else if (invert && wheelDirection === 'anticlockwise')\n    angle = (wheelAngle + 180) - angle;\n  // anticlockwise (input handling)\n  else if (wheelDirection === 'anticlockwise')\n    angle = wheelAngle - angle;\n  return mod(angle, 360);\n}\n\n/**\n * @desc Get the current handle position for a given color\n * @param props - wheel props\n * @param color\n */\nexport function getWheelHandlePosition(props: Partial<WheelProps>, color: IroColor) {\n  const hsv = color.hsv;\n  const { cx, cy } = getWheelDimensions(props);\n  const handleRange = getHandleRange(props);\n  const handleAngle = (180 + translateWheelAngle(props, hsv.h, true)) * (TAU / 360);\n  const handleDist = (hsv.s / 100) * handleRange;\n  const direction = props.wheelDirection === 'clockwise' ? -1 : 1;\n  return {\n    x: cx + handleDist * Math.cos(handleAngle) * direction,\n    y: cy + handleDist * Math.sin(handleAngle) * direction,\n  }\n}\n\n/**\n * @desc Get the current wheel value from user input\n * @param props - wheel props\n * @param x - global input x position\n * @param y - global input y position\n */\nexport function getWheelValueFromInput(props: Partial<WheelProps>, x: number, y: number) {\n  const { cx, cy } = getWheelDimensions(props);\n  const handleRange = getHandleRange(props);\n  x = cx - x;\n  y = cy - y;\n  // Calculate the hue by converting the angle to radians\n  const hue = translateWheelAngle(props, Math.atan2(-y, -x) * (360 / TAU));\n  // Find the point's distance from the center of the wheel\n  // This is used to show the saturation level\n  const handleDist = Math.min(dist(x, y), handleRange);\n  return {\n    h: Math.round(hue),\n    s: Math.round((100 / handleRange) * handleDist)\n  };\n}","import { IroColorPickerOptions } from './colorPickerOptions';\nimport { IroColor, IroColorValue } from './color';\n\nexport interface TriangleWheelProps extends IroColorPickerOptions {\n  color: IroColor;\n  trianglePoints: {\n    x: number;\n    y: number;\n  }[];\n}\n\n/**\n * @desc Get the point as the center of the wheel\n * @param props - wheel props\n */\nexport function getTriangleWheelDimensions(props: Partial<TriangleWheelProps>) {\n  const rad = props.width / 2;\n  const triangleR = rad * 7/8;\n  const triangleH = triangleR * 3/2;\n  const triangleA = triangleR * 3/Math.sqrt(3)\n\n\n  return {\n    width: props.width,\n    radius: rad - props.borderWidth,\n    trianglePoints: [\n      {\n        x: rad,\n        y: rad/8\n      },\n      {\n        x: rad - triangleA/2,\n        y: rad/8 + triangleH,\n      },\n      {\n        x: rad + triangleA/2,\n        y: rad/8 + triangleH,\n      }\n    ],\n    cx: rad,\n    cy: rad\n  };\n}\n\n/**\n * @desc Translate an angle according to wheelAngle and wheelDirection\n * @param props - wheel props\n * @param angle - input angle\n */\nexport function translateTriangleWheelAngle(props: Partial<TriangleWheelProps>, angle: number, invert?: boolean) {\n  const wheelAngle = props.wheelAngle;\n  const wheelDirection = props.wheelDirection\n  if ((!invert && wheelDirection === 'clockwise') || (invert && wheelDirection === 'anticlockwise')) {\n    angle = (invert ? 180 : 360) - (wheelAngle - angle);\n  } \n  else {\n    angle = wheelAngle + angle;\n  }\n  // javascript's modulo operator doesn't produce positive numbers with negative input\n  // https://dev.to/maurobringolf/a-neat-trick-to-compute-modulo-of-negative-numbers-111e\n  return (angle % 360 + 360) % 360;\n}\n\n/**\n * @desc Get the current handle position for a given color\n * @param props - wheel props\n * @param color\n */\nexport function getTriangleWheelHandlePosition(props: Partial<TriangleWheelProps>, color: IroColor) {\n  const hsv = color.hsv;\n  const { radius, cx, cy } = getTriangleWheelDimensions(props);\n  const handleRange = props.width / 2 - props.padding - props.handleRadius - props.borderWidth;\n  const handleAngle = (180 + translateTriangleWheelAngle(props, hsv.h, true)) * (Math.PI / 180);\n  //const handleDist = (hsv.s / 100) * handleRange;\n  const direction = props.wheelDirection === 'clockwise' ? -1 : 1;\n  return {\n    x: cx + (radius - props.padding) * Math.cos(handleAngle) * direction,\n    y: cy + (radius - props.padding) * Math.sin(handleAngle) * direction,\n  }\n}\n\n/**\n * @desc Get the current wheel value from user input\n * @param props - wheel props\n * @param x - global input x position\n * @param y - global input y position\n */\nexport function getTriangleWheelValueFromInput(props: Partial<TriangleWheelProps>, x: number, y: number) {\n  const { cx, cy } = getTriangleWheelDimensions(props);\n  x = cx - x;\n  y = cy - y;\n  // Calculate the hue by converting the angle to radians\n  const hue = translateTriangleWheelAngle(props, Math.atan2(-y, -x) * (180 / Math.PI));\n\n  return {\n    h: Math.round(hue)\n  };\n}","import { IroColorPickerOptions } from './colorPickerOptions';\nimport { IroColor, IroColorValue } from './color';\n\nexport interface HueRingProps extends IroColorPickerOptions {\n  color: IroColor;\n  ringWidth: number\n}\n\n/**\n * @desc Get the point as the center of the ring\n * @param props - ring props\n */\nexport function getHueRingDimensions(props: Partial<HueRingProps>) {\n  const rad = props.width / 2;\n  const radius = rad - props.borderWidth\n\n  return {\n    width: props.width,\n    radius: radius,\n    ringWidth: props.ringWidth || (props.padding + props.handleRadius + props.borderWidth) * 2,\n    cx: rad,\n    cy: rad,\n    borderWidth: props.borderWidth\n  };\n}\n\n/**\n * @desc Translate an angle according to wheelAngle and wheelDirection\n * @param props - wheel props\n * @param angle - input angle\n */\nexport function translateHueRingAngle(props: Partial<HueRingProps>, angle: number, invert?: boolean) {\n  const wheelAngle = props.wheelAngle;\n  const wheelDirection = props.wheelDirection\n  if ((!invert && wheelDirection === 'clockwise') || (invert && wheelDirection === 'anticlockwise')) {\n    angle = (invert ? 180 : 360) - (wheelAngle - angle);\n  } \n  else {\n    angle = wheelAngle + angle;\n  }\n  // javascript's modulo operator doesn't produce positive numbers with negative input\n  // https://dev.to/maurobringolf/a-neat-trick-to-compute-modulo-of-negative-numbers-111e\n  return (angle % 360 + 360) % 360;\n}\n\n/**\n * @desc Get the current handle position for a given color\n * @param props - wheel props\n * @param color\n */\nexport function getHueRingHandlePosition(props: Partial<HueRingProps>, color: IroColor) {\n  const hsv = color.hsv;\n  const { radius, cx, cy } = getHueRingDimensions(props);\n  const handleAngle = (180 + translateHueRingAngle(props, hsv.h, true)) * (Math.PI / 180);\n  const direction = props.wheelDirection === 'clockwise' ? -1 : 1;\n  const ringWidth = props.ringWidth ? props.ringWidth : (props.padding + props.handleRadius + props.borderWidth) * 2;\n  return {\n    x: cx + (radius - ringWidth/2) * Math.cos(handleAngle) * direction,\n    y: cy + (radius - ringWidth/2) * Math.sin(handleAngle) * direction,\n  }\n}\n\n/**\n * @desc Get the current wheel value from user input\n * @param props - wheel props\n * @param x - global input x position\n * @param y - global input y position\n */\nexport function getHueRingValueFromInput(props: Partial<HueRingProps>, x: number, y: number) {\n  const { cx, cy } = getHueRingDimensions(props);\n  x = cx - x;\n  y = cy - y;\n  // Calculate the hue by converting the angle to radians\n  const hue = translateHueRingAngle(props, Math.atan2(-y, -x) * (180 / Math.PI));\n\n  return {\n    h: Math.round(hue)\n  };\n}","import { IroColorPickerOptions } from './colorPickerOptions';\nimport { IroColor, IroColorValue } from './color';\nimport {getWheelDimensions, translateWheelAngle} from \"./wheel\";\n\nexport interface TriangleProps extends IroColorPickerOptions {\n  color: IroColor;\n  trianglePoints: {\n    x: number;\n    y: number;\n  }[];\n  rotation?: number;\n}\n\n/**\n * @desc Get the point as the center of the wheel\n * @param props - wheel props\n */\nexport function getTriangleDimensions(props: Partial<TriangleProps>) {\n  const rad = props.width / 2;\n  const height = (props.width * Math.sqrt(3))/2;\n\n\n  return {\n    width: props.width,\n    height: height,\n    radius: rad - props.borderWidth,\n    trianglePoints: [\n      {\n        x: props.width/2,\n        y: 0\n      },\n      {\n        x: 0,\n        y: height,\n      },\n      {\n        x: props.width,\n        y: height,\n      }\n    ],\n    cx: rad,\n    cy: rad,\n    borderWidth: props.borderWidth\n  };\n}\n\n/**\n * @desc Translate an angle according to wheelAngle and wheelDirection\n * @param props - wheel props\n * @param angle - input angle\n */\nexport function translateTriangleAngle(props: Partial<TriangleProps>, angle: number, invert?: boolean) {\n  const wheelAngle = props.wheelAngle;\n  const wheelDirection = props.wheelDirection\n  if ((!invert && wheelDirection === 'clockwise') || (invert && wheelDirection === 'anticlockwise')) {\n    angle = (invert ? 180 : 360) - (wheelAngle - angle);\n  } \n  else {\n    angle = wheelAngle + angle;\n  }\n  // javascript's modulo operator doesn't produce positive numbers with negative input\n  // https://dev.to/maurobringolf/a-neat-trick-to-compute-modulo-of-negative-numbers-111e\n  return (angle % 360 + 360) % 360;\n}\n\n/**\n * @desc Get the current handle position for a given color\n * @param props - wheel props\n * @param color\n */\nexport function getTriangleHandlePosition(props: Partial<TriangleProps>, color: IroColor) {\n  const hsv = color.hsv;\n  const { height, width } = getTriangleDimensions(props);\n  const handleAngleDeg = (180 + translateTriangleAngle(props, hsv.h, true));\n\n  return {\n    x: width * (1 + (hsv.v * (hsv.s - 200))/20000),\n    y: height * (1 - hsv.s * hsv.v/10000),\n  }\n\n}\n\n/**\n * @desc Get the current wheel value from user input\n * @param props - wheel props\n * @param x - global input x position\n * @param y - global input y position\n */\nexport function getTriangleValueFromInput(props: Partial<TriangleProps>, x: number, y: number) {\n  const { width, height, cx, cy } = getTriangleDimensions(props);\n\n  const rotation = props.rotation ? props.rotation * Math.PI/180 : 0;\n\n  let s: number;\n  let v: number;\n\n  let newX = x;\n  let newY = y;\n\n  if (props.rotation) {\n    const sin = Math.sin(-1 * rotation)\n    const cos = Math.cos(-1 * rotation)\n\n    const xc = x - cx - (sin * cos * 15)\n    const yc = y - cy - (sin * cos * 15)\n\n    newX = xc * cos - yc * sin\n    newY = xc * sin + yc * cos\n\n    newX += cx\n    newY += cy\n\n  }\n\n  s = (200 * width * (height - newY))/((3 * height * width) - (2 * height * newX) - width * newY);\n  v = 50 * (3 - (newY/height) - (2 * newX/width));\n\n  return {\n    s: Math.min(100, Math.max( 0, Math.round(s))),\n    v: Math.min(100, Math.max( 0, Math.round(v)))\n  };\n}\n\n/**\n * @desc Get the gradient stops for a triangle\n * @param props - box props\n * @param color\n */\nexport function getTriangleGradients(props: Partial<TriangleProps>, color: IroColor) {\n  const hue = color.hue;\n  return [\n    // saturation gradient\n    [\n      [0, '#fff'],\n      [100, `hsl(${hue},100%,50%)`],\n    ],\n    // lightness gradient\n    [\n      [0, 'rgba(0,0,0,0)'],\n      [100, '#000'],\n    ]\n  ];\n}","import { IroColor } from './color';\nimport { CssGradientStops } from './css';\nimport { IroColorPickerOptions } from './colorPickerOptions';\n\nexport interface BoxOptions extends IroColorPickerOptions {\n  color: IroColor;\n}\n\n/**\n * @desc Get the CSS styles for the box root element\n * @param props - box props\n */\nexport function getBoxStyles(props: Partial<BoxOptions>) {\n  return {\n    [props.layoutDirection === 'horizontal' ? 'marginLeft' : 'marginTop']: props.sliderMargin\n  }\n}\n\n/**\n * @desc Get the bounding dimensions of the box\n * @param props - box props\n */\nexport function getBoxDimensions(props: Partial<BoxOptions>) {\n  const { width, boxHeight, padding, handleRadius } = props;\n  return {\n    width: width,\n    height: boxHeight ?? width,\n    radius: padding + handleRadius\n  };\n}\n\n/**\n * @desc Get the current box value from user input\n * @param props - box props\n * @param x - global input x position\n * @param y - global input y position\n */\nexport function getBoxValueFromInput(props: Partial<BoxOptions>, x: number, y: number) {\n  const { width, height, radius } = getBoxDimensions(props);\n  const handleStart = radius;\n  const handleRangeX = width - radius * 2;\n  const handleRangeY = height - radius * 2;\n  const percentX = ((x - handleStart) / handleRangeX) * 100;\n  const percentY = ((y - handleStart) / handleRangeY) * 100;\n  return {\n    s: Math.max(0, Math.min(percentX, 100)),\n    v: Math.max(0, Math.min(100 - percentY, 100))\n  }\n}\n\n/**\n * @desc Get the current box handle position for a given color\n * @param props - box props\n * @param color\n */\nexport function getBoxHandlePosition(props: Partial<BoxOptions>, color: IroColor) {\n  const { width, height, radius } = getBoxDimensions(props);\n  const hsv = color.hsv;\n  const handleStart = radius;\n  const handleRangeX = width - radius * 2;\n  const handleRangeY = height - radius * 2;\n  return { \n    x: handleStart + (hsv.s / 100) * handleRangeX,\n    y: handleStart + (handleRangeY - ((hsv.v / 100) * handleRangeY))\n  }\n}\n\n/**\n * @desc Get the gradient stops for a box\n * @param props - box props\n * @param color\n */\nexport function getBoxGradients(props: Partial<BoxOptions>, color: IroColor): CssGradientStops[] {\n  const hue = color.hue;\n  return [\n    // saturation gradient\n    [\n      [0, '#fff'],\n      [100, `hsl(${hue},100%,50%)`],\n    ],\n    // lightness gradient\n    [\n      [0, 'rgba(0,0,0,0)'],\n      [100, '#000'],\n    ]\n  ];\n}","import { IroColorPickerOptions } from './colorPickerOptions';\n\n// Keep track of html <base> elements for resolveSvgUrl\n// getElementsByTagName returns a live HTMLCollection, which stays in sync with the DOM tree\n// So it only needs to be called once\nlet BASE_ELEMENTS:  HTMLCollectionOf<HTMLBaseElement> | undefined;\n\n/**\n * @desc Resolve an SVG reference URL\n * This is required to work around how Safari and iOS webviews handle gradient URLS under certain conditions\n * If a page is using a client-side routing library which makes use of the HTML <base> tag, \n * Safari won't be able to render SVG gradients properly (as they are referenced by URLs)\n * More info on the problem: \n * https://stackoverflow.com/questions/19742805/angular-and-svg-filters/19753427#19753427\n * https://github.com/jaames/iro.js/issues/18\n * https://github.com/jaames/iro.js/issues/45\n * https://github.com/jaames/iro.js/pull/89\n * @props url - SVG reference URL\n */\nexport function resolveSvgUrl(url: string) {\n  if (!BASE_ELEMENTS)\n    BASE_ELEMENTS = document.getElementsByTagName('base');\n  // Sniff useragent string to check if the user is running Safari\n  const ua = window.navigator.userAgent;\n  const isSafari = /^((?!chrome|android).)*safari/i.test(ua);\n  const isIos = /iPhone|iPod|iPad/i.test(ua);\n  const location = window.location;\n  return ((isSafari || isIos) && (BASE_ELEMENTS.length > 0)) ? `${location.protocol}//${location.host}${location.pathname}${location.search}${url}` : url;\n}\n\n/**\n * @desc Get the path commands to draw an svg arc\n * @props cx - arc center point x\n * @props cy - arc center point y\n * @props radius - arc radius\n * @props startAngle - arc start angle\n * @props endAngle - arc end angle\n */\nexport function getSvgArcPath(cx: number, cy: number, radius: number, startAngle: number, endAngle: number) {\n  const largeArcFlag = endAngle - startAngle <= 180 ? 0 : 1;\n  startAngle *= Math.PI / 180;\n  endAngle *= Math.PI / 180;\n  const x1 = cx + radius * Math.cos(endAngle);\n  const y1 = cy + radius * Math.sin(endAngle);\n  const x2 = cx + radius * Math.cos(startAngle);\n  const y2 = cy + radius * Math.sin(startAngle);\n  return `M ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 0 ${x2} ${y2}`;\n}\n\n/**\n * @desc Given a specifc (x, y) position, test if there's a handle there and return its index, else return null.\n *       This is used for components like the box and wheel which support multiple handles when multicolor is active\n * @props x - point x position\n * @props y - point y position\n * @props handlePositions - array of {x, y} coords for each handle\n */\nexport function getHandleAtPoint(props: Partial<IroColorPickerOptions>, x: number, y: number, handlePositions: {x: number, y: number}[]) {\n  for (let i = 0; i < handlePositions.length; i++) {\n    const dX = handlePositions[i].x - x;\n    const dY = handlePositions[i].y - y;\n    const dist = Math.sqrt(dX * dX + dY * dY);\n    if (dist < props.handleRadius) {\n      return i;\n    }\n  }\n  return null;\n}","import { IroColorPickerOptions } from './colorPickerOptions';\n\nexport function cssBorderStyles(props: IroColorPickerOptions) {\n  return {\n    boxSizing: 'border-box',\n    border: `${ props.borderWidth }px solid ${ props.borderColor }`\n  };\n}\n\nexport type CssGradientType = 'linear' | 'radial' | 'conical';\nexport type CssGradientStops = [number, number | string][];\n\nexport function cssGradient(type: CssGradientType, direction: string, stops: CssGradientStops) {\n  return `${ type }-gradient(${ direction }, ${ stops.map(([o, col]) => `${ col } ${ o }%`).join(',') })`;\n}\n\nexport function cssValue(value: number | string) {\n  if (typeof(value) === 'string')\n    return value;\n  return `${ value }px`;\n}","import { IroColor, IroColorValue } from './color';\n\nexport type LayoutDirection = 'vertical' | 'horizontal' | '';\n\nexport type WheelDirection = 'clockwise' | 'anticlockwise' | '';\n\nexport interface IroColorPickerOptions {\n  width?: number;\n  height?: number;\n  color?: IroColorValue;\n  colors?: IroColorValue[];\n  padding?: number;\n  layoutDirection?: LayoutDirection;\n  borderColor?: string;\n  borderWidth?: number;\n  handleRadius?: number;\n  activeHandleRadius?: number;\n  handleSvg?: string;\n  handleProps?: any;\n  wheelLightness?: boolean;\n  wheelAngle?: number;\n  wheelDirection?: WheelDirection;\n  sliderSize?: number;\n  sliderMargin?: number;\n  boxHeight?: number;\n}\n\nexport const iroColorPickerOptionDefaults: IroColorPickerOptions = {\n  width: 300,\n  height: 300,\n  color: '#fff',\n  colors: [],\n  padding: 6,\n  layoutDirection: 'vertical',\n  borderColor: '#fff',\n  borderWidth: 0,\n  handleRadius: 8,\n  activeHandleRadius: null,\n  handleSvg: null,\n  handleProps: {x: 0, y: 0},\n  wheelLightness: true,\n  wheelAngle: 0,\n  wheelDirection: 'anticlockwise',\n  sliderSize: null,\n  sliderMargin: 12,\n  boxHeight: null\n}"],"names":["CSS_UNIT","PERMISSIVE_MATCH_3","PERMISSIVE_MATCH_4","REGEX_FUNCTIONAL_RGB","RegExp","REGEX_FUNCTIONAL_RGBA","REGEX_FUNCTIONAL_HSL","REGEX_FUNCTIONAL_HSLA","REGEX_HEX_3","HEX_START","REGEX_HEX_4","REGEX_HEX_6","REGEX_HEX_8","log","round","floor","Math","clamp","num","min","max","parseUnit","str","isPercentage","indexOf","parseFloat","parseHexInt","parseInt","intToHex","int","toString","padStart","IroColor","constructor","value","onChange","this","$","h","s","v","a","set","initialValue","test","hexString","rgbString","hslString","Error","hsv","rgb","hsl","kelvin","setChannel","format","channel","[object Object]","reset","hsva","clone","unbind","undefined","i","f","p","q","t","mod","g","b","r","delta","hue","saturation","l","divisor","temp","minTemp","maxTemp","kelvinToRgb","newValue","oldValue","changes","key","alpha","rgbToKelvin","red","green","blue","hsvToRgb","rgbToHsv","rgba","hsvToHsl","hslToHsv","hsla","match","exec","rgbaString","hex8String","hslaString","sliderDefaultOptions","sliderShape","sliderType","minTemperature","maxTemperature","getSliderStyles","props","layoutDirection","sliderMargin","getSliderDimensions","width","sliderSize","borderWidth","handleRadius","padding","ishorizontal","handleStart","handleRange","height","cx","cy","radius","x","y","getCurrentSliderValue","color","getSliderValueFromInput","handlePos","percent","getSliderHandlePosition","midPoint","getSliderGradient","stops","numStops","range","stop","push","noSat","fullSat","getSliderGradientCoords","x1","y1","x2","y2","TAU","PI","dist","sqrt","getHandleRange","isInputInsideWheel","getWheelDimensions","translateWheelAngle","angle","invert","wheelAngle","wheelDirection","getWheelHandlePosition","handleAngle","handleDist","direction","cos","sin","getWheelValueFromInput","atan2","getTriangleWheelDimensions","rad","triangleR","triangleH","triangleA","trianglePoints","translateTriangleWheelAngle","getTriangleWheelHandlePosition","getTriangleWheelValueFromInput","getHueRingDimensions","ringWidth","translateHueRingAngle","getHueRingHandlePosition","getHueRingValueFromInput","getTriangleDimensions","translateTriangleAngle","getTriangleHandlePosition","getTriangleValueFromInput","rotation","newX","newY","xc","yc","getTriangleGradients","getBoxStyles","getBoxDimensions","boxHeight","getBoxValueFromInput","percentY","getBoxHandlePosition","handleRangeY","getBoxGradients","BASE_ELEMENTS","resolveSvgUrl","url","document","getElementsByTagName","ua","window","navigator","userAgent","isSafari","isIos","location","length","protocol","host","pathname","search","getSvgArcPath","startAngle","endAngle","largeArcFlag","getHandleAtPoint","handlePositions","dX","dY","cssBorderStyles","boxSizing","border","borderColor","cssGradient","type","map","o","col","join","cssValue","iroColorPickerOptionDefaults","colors","activeHandleRadius","handleSvg","handleProps","wheelLightness"],"mappings":"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"}