{"version":3,"file":"iro-core.js","sources":["../src/color.ts","../src/slider.ts","../src/wheel.ts","../src/util.ts","../src/triangleWheel.ts","../src/hueRing.ts","../src/triangle.ts","../src/box.ts","../src/css.ts","../src/colorPickerOptions.ts"],"sourcesContent":["// Some regular expressions for rgb() and hsl() Colors are borrowed from tinyColor\n// https://github.com/bgrins/TinyColor\n// Kelvin temperature math borrowed from Neil Barlett's implementation\n// from https://github.com/neilbartlett/color-temperature\n\n// https://www.w3.org/TR/css3-values/#integers\nconst CSS_INTEGER = '[-\\\\+]?\\\\d+%?';\n// http://www.w3.org/TR/css3-values/#number-value\nconst CSS_NUMBER = '[-\\\\+]?\\\\d*\\\\.\\\\d+%?';\n// Allow positive/negative integer/number. Don't capture the either/or, just the entire outcome\nconst CSS_UNIT = '(?:' + CSS_NUMBER + ')|(?:' + CSS_INTEGER + ')';\n\n// Parse function params\n// Parens and commas are optional, and this also allows for whitespace between numbers\nconst PERMISSIVE_MATCH_3 = '[\\\\s|\\\\(]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')\\\\s*\\\\)?';\nconst PERMISSIVE_MATCH_4 = '[\\\\s|\\\\(]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')\\\\s*\\\\)?';\n\n// Regex patterns for functional color strings\nconst REGEX_FUNCTIONAL_RGB = new RegExp('rgb' + PERMISSIVE_MATCH_3);\nconst REGEX_FUNCTIONAL_RGBA = new RegExp('rgba' + PERMISSIVE_MATCH_4);\nconst REGEX_FUNCTIONAL_HSL = new RegExp('hsl' + PERMISSIVE_MATCH_3);\nconst REGEX_FUNCTIONAL_HSLA = new RegExp('hsla' + PERMISSIVE_MATCH_4);\n\n// Color string parsing regex\nconst HEX_START = '^(?:#?|0x?)';\nconst HEX_INT_SINGLE = '([0-9a-fA-F]{1})';\nconst HEX_INT_DOUBLE = '([0-9a-fA-F]{2})';\nconst REGEX_HEX_3 = new RegExp(HEX_START + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + '$');\nconst REGEX_HEX_4 = new RegExp(HEX_START + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + '$');\nconst REGEX_HEX_6 = new RegExp(HEX_START + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + '$');\nconst REGEX_HEX_8 = new RegExp(HEX_START + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + '$');\n\n// Kelvin temperature bounds\nconst KELVIN_MIN = 2000;\nconst KELVIN_MAX = 40000;\n\n// Math shorthands\nconst { log, round, floor } = Math;\n\n/**\n * @desc Clamp a number between a min and max value\n * @param num - input value\n * @param min - min allowed value\n * @param max - max allowed value\n */\nfunction clamp(num: number, min: number, max: number): number {\n  return Math.min(Math.max(num, min), max)\n}\n\n/**\n * @desc Parse a css unit string - either regular int or a percentage number\n * @param str - css unit string\n * @param max - max unit value, used for calculating percentages\n */\nfunction parseUnit(str: string, max: number): number {\n  const isPercentage = str.indexOf('%') > -1;\n  const num = parseFloat(str);\n  return isPercentage ? (max / 100) * num : num;\n}\n\n/**\n * @desc Parse hex str to an int\n * @param str - hex string to parse\n */\nfunction parseHexInt(str: string): number {\n  return parseInt(str, 16);\n}\n\n/**\n * @desc Convert nunber into to 2-digit hex\n * @param int - number to convert\n */\nfunction intToHex(int: number): string {\n  return int.toString(16).padStart(2, '0');\n}\n\nexport interface ColorChanges {\n  h: boolean;\n  s: boolean;\n  v: boolean;\n  a: boolean;\n}\n\n// all hsv color channels are optional by design\nexport interface HsvColor {\n  h?: number;\n  s?: number;\n  v?: number;\n  a?: number;\n}\n\nexport interface RgbColor {\n  r: number;\n  g: number;\n  b: number;\n  a?: number;\n}\n\nexport interface HslColor {\n  h: number;\n  s: number;\n  l: number;\n  a?: number;\n}\n\nexport interface KelvinColor {\n  kelvin: number;\n}\n\nexport type IroColorValue = IroColor | HsvColor | RgbColor | HslColor | KelvinColor | string;\n\nexport class IroColor {\n  // internal color value storage\n  private $: HsvColor;\n  private onChange: Function;\n  private initialValue: HsvColor;\n\n  public index: number;\n\n  /**\n    * @constructor Color object\n    * @param value - initial color value\n  */\n  constructor(value?: IroColorValue, onChange?: Function) {\n    // The default Color value\n    this.$ = {h: 0, s: 0, v: 0, a: 1};\n    if (value) this.set(value);\n    // The watch callback function for this Color will be stored here\n    this.onChange = onChange;\n    this.initialValue = { ...this.$ }; // copy initial value\n  }\n\n  /**\n    * @desc Set the Color from any valid value\n    * @param value - new color value\n  */\n  public set(value: IroColorValue) {\n    if (typeof value === 'string') {\n      if (/^(?:#?|0x?)[0-9a-fA-F]{3,8}$/.test(value as string)) {\n        this.hexString = value as string;\n      }\n      else if (/^rgba?/.test(value as string)) {\n        this.rgbString = value as string;\n      }\n      else if (/^hsla?/.test(value as string)) {\n        this.hslString = value as string;\n      }\n    }\n    else if (typeof value === 'object') {\n      if (value instanceof IroColor) {\n        this.hsv = value.hsv;\n      }\n      else if ('r' in value && 'g' in value && 'b' in value) {\n        this.rgb = value;\n      }\n      else if ('h' in value && 's' in value && 'v' in value) {\n        this.hsv = value;\n      }\n      else if ('h' in value && 's' in value && 'l' in value) {\n        this.hsl = value;\n      }\n      else if ('kelvin' in value) {\n        this.kelvin = value.kelvin;\n      }\n    }\n    else {\n      throw new Error('Invalid color value');\n    }\n  }\n\n  /**\n    * @desc Shortcut to set a specific channel value\n    * @param format - hsv | hsl | rgb\n    * @param channel - individual channel to set, for example if model = hsl, chanel = h | s | l\n    * @param value - new value for the channel\n  */\n  public setChannel(format: string, channel: string, value: number) {\n    this[format] = {...this[format], [channel]: value};\n  }\n\n  /**\n   * @desc Reset color back to its initial value\n   */\n  public reset() {\n    this.hsva = this.initialValue;\n  }\n\n  /**\n    * @desc make new Color instance with the same value as this one\n  */\n  public clone() {\n    return new IroColor(this);\n  }\n\n  /**\n   * @desc remove color onChange\n   */\n  public unbind() {\n    this.onChange = undefined;\n  }\n\n  /**\n    * @desc Convert hsv object to rgb\n    * @param hsv - hsv color object\n  */\n  public static hsvToRgb(hsv: HsvColor): RgbColor {\n    const h = hsv.h / 60;\n    const s = hsv.s / 100;\n    const v = hsv.v / 100;\n    const i = floor(h);\n    const f = h - i;\n    const p = v * (1 - s);\n    const q = v * (1 - f * s);\n    const t = v * (1 - (1 - f) * s);\n    const mod = i % 6;\n    const r = [v, q, p, p, t, v][mod];\n    const g = [t, v, v, q, p, p][mod];\n    const b = [p, p, t, v, v, q][mod];\n    return {\n      r: clamp(r * 255, 0, 255), \n      g: clamp(g * 255, 0, 255), \n      b: clamp(b * 255, 0, 255)\n    };\n  }\n\n  /**\n    * @desc Convert rgb object to hsv\n    * @param rgb - rgb object\n  */\n  public static rgbToHsv(rgb: RgbColor): HsvColor {\n    const r = rgb.r / 255;\n    const g = rgb.g / 255;\n    const b = rgb.b / 255;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const delta = max - min;\n    let hue = 0;\n    let value = max;\n    let saturation = max === 0 ? 0 : delta / max;\n    switch (max) {\n      case min: \n        hue = 0; // achromatic\n        break;\n      case r: \n        hue = (g - b) / delta + (g < b ? 6 : 0);\n        break;\n      case g: \n        hue = (b - r) / delta + 2;\n        break;\n      case b:\n        hue = (r - g) / delta + 4;\n        break;\n    }\n    return {\n      h: (hue * 60) % 360,\n      s: clamp(saturation * 100, 0, 100),\n      v: clamp(value * 100, 0, 100)\n    }\n  }\n\n  /**\n    * @desc Convert hsv object to hsl\n    * @param hsv - hsv object\n  */\n  public static hsvToHsl(hsv: HsvColor): HslColor {\n    const s = hsv.s / 100;\n    const v = hsv.v / 100;\n    const l = (2 - s) * v;\n    const divisor = l <= 1 ? l : (2 - l);\n    // Avoid division by zero when lightness is close to zero\n    const saturation = divisor < 1e-9 ? 0 : (s * v) / divisor;\n    return {\n      h: hsv.h,\n      s: clamp(saturation * 100, 0, 100),\n      l: clamp(l * 50, 0, 100)\n    };\n  }\n\n  /**\n    * @desc Convert hsl object to hsv\n    * @param hsl - hsl object\n  */\n  public static hslToHsv(hsl: HslColor): HsvColor {\n    const l = hsl.l * 2;\n    const s = (hsl.s * ((l <= 100) ? l : 200 - l)) / 100;\n    // Avoid division by zero when l + s is near 0\n    const saturation = (l + s < 1e-9) ? 0 : (2 * s) / (l + s);\n    return {\n      h: hsl.h,\n      s: clamp(saturation * 100, 0, 100),\n      v: clamp((l + s) / 2, 0, 100)\n    };\n  }\n\n  /**\n    * @desc Convert a kelvin temperature to an approx, RGB value\n    * @param kelvin - kelvin temperature\n  */\n  public static kelvinToRgb(kelvin: number): RgbColor {\n    const temp = kelvin / 100;\n    let r, g, b;\n    if (temp < 66) {\n      r = 255\n      g = -155.25485562709179 - 0.44596950469579133 * (g = temp-2) + 104.49216199393888 * log(g)\n      b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp-10) + 115.67994401066147 * log(b)\n    } else {\n      r = 351.97690566805693 + 0.114206453784165 * (r = temp-55) - 40.25366309332127 * log(r)\n      g = 325.4494125711974 + 0.07943456536662342 * (g = temp-50) - 28.0852963507957 * log(g)\n      b = 255\n    }\n    return {\n      r: clamp(floor(r), 0, 255),\n      g: clamp(floor(g), 0, 255),\n      b: clamp(floor(b), 0, 255)\n    };\n  }\n\n   /**\n    * @desc Convert an RGB color to an approximate kelvin temperature\n    * @param kelvin - kelvin temperature\n  */\n  public static rgbToKelvin(rgb: RgbColor): number {\n    const { r, g, b } = rgb;\n    const eps = 0.4;\n    let minTemp = KELVIN_MIN;\n    let maxTemp = KELVIN_MAX;\n    let temp;\n    while (maxTemp - minTemp > eps) {\n      temp = (maxTemp + minTemp) * 0.5;\n      const rgb = IroColor.kelvinToRgb(temp);\n      if ((rgb.b / rgb.r) >= (b / r)) {\n        maxTemp = temp;\n      } else {\n        minTemp = temp;\n      }\n    }\n    return temp;\n  }\n\n  public get hsv(): HsvColor {\n    // value is cloned to allow changes to be made to the values before passing them back\n    const value = this.$;\n    return {h: value.h, s: value.s, v: value.v};\n  }\n\n  public set hsv(newValue: HsvColor) {\n    const oldValue = this.$;\n\n    newValue = { ...oldValue, ...newValue };\n    // If this Color is being watched for changes we need to compare the new and old values to check the difference\n    // Otherwise we can just be lazy\n    if (this.onChange) {\n      // Compute changed values\n      let changes: ColorChanges = {\n        h: false,\n        v: false,\n        s: false,\n        a: false,\n      };\n\n      for (let key in oldValue) {\n        changes[key] = newValue[key] != oldValue[key]\n      };\n      // Update the old value\n      this.$ = newValue;\n      // If the value has changed, call hook callback\n      if (changes.h || changes.s || changes.v || changes.a) this.onChange(this, changes);\n    } else {\n      this.$ = newValue;\n    }\n  }\n\n  public get hsva(): HsvColor {\n    return {...this.$};\n  }\n\n  public set hsva(value: HsvColor) {\n    this.hsv = value;\n  }\n\n  public get hue(): number {\n    return this.$.h;\n  }\n\n  public set hue(value: number) {\n    this.hsv = { h: value };\n  }\n\n  public get saturation(): number {\n    return this.$.s;\n  }\n\n  public set saturation(value: number) {\n    this.hsv = { s: value };\n  }\n\n  public get value(): number {\n    return this.$.v;\n  }\n\n  public set value(value: number) {\n    this.hsv = { v: value };\n  }\n\n  public get alpha(): number {\n    return this.$.a;\n  }\n\n  public set alpha(value: number) {\n    this.hsv = { ...this.hsv, a: value };\n  }\n\n  public get kelvin(): number {\n    return IroColor.rgbToKelvin(this.rgb);\n  }\n\n  public set kelvin(value: number) {\n    this.rgb = IroColor.kelvinToRgb(value);\n  }\n\n  public get red(): number {\n    const rgb = this.rgb;\n    return rgb.r;\n  }\n\n  public set red(value: number) {\n    this.rgb = { ...this.rgb, r: value };\n  }\n\n  public get green(): number {\n    const rgb = this.rgb;\n    return rgb.g;\n  }\n\n  public set green(value: number) {\n    this.rgb = { ...this.rgb, g: value };\n  }\n\n  public get blue(): number {\n    const rgb = this.rgb;\n    return rgb.b;\n  }\n\n  public set blue(value: number) {\n    this.rgb = { ...this.rgb, b: value };\n  }\n\n  public get rgb(): RgbColor {\n    const {r, g, b} = IroColor.hsvToRgb(this.$);\n    return {\n      r: round(r),\n      g: round(g),\n      b: round(b),\n    };\n  }\n\n  public set rgb(value: RgbColor) {\n    this.hsv = {\n      ...IroColor.rgbToHsv(value), \n      a: (value.a === undefined) ? 1 : value.a\n    };\n  }\n\n  public get rgba(): RgbColor {\n    return { ...this.rgb, a: this.alpha };\n  }\n\n  public set rgba(value: RgbColor) {\n    this.rgb = value;\n  }\n\n  public get hsl(): HslColor {\n    const {h, s, l} = IroColor.hsvToHsl(this.$);\n    return {\n      h: round(h),\n      s: round(s),\n      l: round(l),\n    };\n  }\n\n  public set hsl(value: HslColor) {\n    this.hsv = {\n      ...IroColor.hslToHsv(value), \n      a: (value.a === undefined) ? 1 : value.a\n    };\n  }\n\n  public get hsla(): HslColor {\n    return { ...this.hsl, a: this.alpha };\n  }\n\n  public set hsla(value: HslColor) {\n    this.hsl = value;\n  }\n\n  public get rgbString(): string {\n    const rgb = this.rgb;\n    return `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;\n  }\n\n  public set rgbString(value: string) {\n    let match;\n    let r, g, b, a = 1;\n    if (match = REGEX_FUNCTIONAL_RGB.exec(value)) {\n      r = parseUnit(match[1], 255);\n      g = parseUnit(match[2], 255);\n      b = parseUnit(match[3], 255);\n    }\n    else if (match = REGEX_FUNCTIONAL_RGBA.exec(value)) {\n      r = parseUnit(match[1], 255);\n      g = parseUnit(match[2], 255);\n      b = parseUnit(match[3], 255);\n      a = parseUnit(match[4], 1);\n    }\n    if (match) {\n      this.rgb = {r, g, b, a};\n    } \n    else {\n      throw new Error('Invalid rgb string');\n    }\n  }\n\n  public get rgbaString(): string {\n    const rgba = this.rgba;\n    return `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;\n  }\n\n  public set rgbaString(value: string) {\n    this.rgbString = value;\n  }\n\n  public get hexString(): string {\n    const rgb = this.rgb;\n    return `#${ intToHex(rgb.r) }${ intToHex(rgb.g) }${ intToHex(rgb.b) }`;\n  }\n\n  public set hexString(value: string) {\n    let match;\n    let r, g, b, a = 255;\n    if (match = REGEX_HEX_3.exec(value)) {\n      r = parseHexInt(match[1]) * 17;\n      g = parseHexInt(match[2]) * 17;\n      b = parseHexInt(match[3]) * 17;\n    }\n    else if (match = REGEX_HEX_4.exec(value)) {\n      r = parseHexInt(match[1]) * 17;\n      g = parseHexInt(match[2]) * 17;\n      b = parseHexInt(match[3]) * 17;\n      a = parseHexInt(match[4]) * 17;\n    }\n    else if (match = REGEX_HEX_6.exec(value)) {\n      r = parseHexInt(match[1]);\n      g = parseHexInt(match[2]);\n      b = parseHexInt(match[3]);\n    }\n    else if (match = REGEX_HEX_8.exec(value)) {\n      r = parseHexInt(match[1]);\n      g = parseHexInt(match[2]);\n      b = parseHexInt(match[3]);\n      a = parseHexInt(match[4]);\n    }\n    if (match) {\n      this.rgb = {r, g, b, a: a / 255};\n    }\n    else {\n      throw new Error('Invalid hex string');\n    }\n  }\n\n  public get hex8String(): string {\n    const rgba = this.rgba;\n    return `#${intToHex(rgba.r)}${intToHex(rgba.g)}${intToHex(rgba.b)}${intToHex(floor(rgba.a * 255))}`;\n  }\n\n  public set hex8String(value: string) {\n    this.hexString = value;\n  }\n\n  public get hslString(): string {\n    const hsl = this.hsl;\n    return `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`;\n  }\n\n  public set hslString(value: string) {\n    let match;\n    let h, s, l, a = 1;\n    if (match = REGEX_FUNCTIONAL_HSL.exec(value)) {\n      h = parseUnit(match[1], 360);\n      s = parseUnit(match[2], 100);\n      l = parseUnit(match[3], 100);\n    }\n    else if (match = REGEX_FUNCTIONAL_HSLA.exec(value)) {\n      h = parseUnit(match[1], 360);\n      s = parseUnit(match[2], 100);\n      l = parseUnit(match[3], 100);\n      a = parseUnit(match[4], 1);\n    }\n    if (match) {\n      this.hsl = {h, s, l, a};\n    } \n    else {\n      throw new Error('Invalid hsl string');\n    }\n  }\n\n  public get hslaString(): string {\n    const hsla = this.hsla;\n    return `hsl(${hsla.h}, ${hsla.s}%, ${hsla.l}%, ${hsla.a})`;\n  }\n\n  public set hslaString(value: string) {\n    this.hslString = value;\n  }\n}","import { IroColor } from './color';\nimport { CssGradientStops } from './css';\nimport { IroColorPickerOptions } from './colorPickerOptions';\n\nexport type SliderShape = 'bar' | 'circle' | '';\nexport type SliderType = 'red' | 'green' | 'blue' |'alpha' | 'hue' | 'saturation' | 'value' | 'kelvin' | '';\n\nexport interface SliderOptions extends IroColorPickerOptions {\n  color: IroColor;\n  sliderShape: SliderShape;\n  sliderType: SliderType;\n  minTemperature: number;\n  maxTemperature: number;\n}\n\nexport const sliderDefaultOptions = {\n  sliderShape: 'bar',\n  sliderType: 'value',\n  minTemperature: 2200,\n  maxTemperature: 11000\n}\n\n/**\n * @desc Get the CSS styles for the slider root\n * @param props - slider props\n */\nexport function getSliderStyles(props: Partial<SliderOptions>) {\n  return {\n    [props.layoutDirection === 'horizontal' ? 'marginLeft' : 'marginTop']: props.sliderMargin\n  }\n}\n\n/**\n * @desc Get the bounding dimensions of the slider\n * @param props - slider props\n */\nexport function getSliderDimensions(props: Partial<SliderOptions>) {\n  let { width, sliderSize: sliderSize, borderWidth, handleRadius, padding, sliderShape } = props;\n  const ishorizontal = props.layoutDirection === 'horizontal';\n  // automatically calculate sliderSize if its not defined\n  sliderSize = sliderSize ?? padding * 2 + handleRadius * 2;\n  if (sliderShape === 'circle') {\n    return {\n      handleStart: props.padding + props.handleRadius,\n      handleRange: width - padding * 2 - handleRadius * 2,\n      width: width,\n      height: width,\n      cx: width / 2,\n      cy: width / 2,\n      radius: width / 2 - borderWidth / 2\n    }\n  } else {\n    return {\n      handleStart: sliderSize / 2,\n      handleRange: width - sliderSize,\n      radius: sliderSize / 2,\n      x: 0,\n      y: 0,\n      width: ishorizontal ? sliderSize : width,\n      height: ishorizontal ? width : sliderSize,\n    }\n  }\n}\n\n/**\n * @desc Get the current slider value for a given color, as a percentage\n * @param props - slider props\n * @param color\n */\nexport function getCurrentSliderValue(props: Partial<SliderOptions>, color: IroColor) {\n  const hsva = color.hsva;\n  const rgb = color.rgb;\n\n  switch (props.sliderType) {\n    case 'red':\n      return rgb.r / 2.55;\n    case 'green':\n      return rgb.g / 2.55;\n    case 'blue':\n      return rgb.b / 2.55;\n    case 'alpha':\n      return hsva.a * 100;\n    case 'kelvin':\n      const { minTemperature, maxTemperature } = props;\n      const temperatureRange = maxTemperature - minTemperature;\n      const percent = ((color.kelvin - minTemperature) / temperatureRange) * 100;\n      // clmap percentage\n      return Math.max(0, Math.min(percent, 100));\n    case 'hue':\n      return hsva.h /= 3.6;\n    case 'saturation':\n      return hsva.s;\n    case 'value':\n    default:\n      return hsva.v;\n  }\n}\n\n/**\n * @desc Get the current slider value from user input\n * @param props - slider props\n * @param x - global input x position\n * @param y - global input y position\n */\nexport function getSliderValueFromInput(props: Partial<SliderOptions>, x: number, y: number) {\n  const { handleRange, handleStart } = getSliderDimensions(props);\n  let handlePos;\n  if (props.layoutDirection === 'horizontal') {\n    handlePos = -1 * y + handleRange + handleStart;\n  } else {\n    handlePos = x - handleStart;\n  }\n  // clamp handle position\n  handlePos = Math.max(Math.min(handlePos, handleRange), 0);\n  const percent = Math.round((100 / handleRange) * handlePos);\n  switch (props.sliderType) {\n    case 'kelvin':\n      const { minTemperature, maxTemperature } = props;\n      const temperatureRange = maxTemperature - minTemperature;\n      return minTemperature + temperatureRange * (percent / 100);\n    case 'alpha':\n      return percent / 100;\n    case 'hue':\n      return percent * 3.6;\n    case 'red':\n    case 'blue':\n    case 'green':\n      return percent * 2.55;\n    default:\n      return percent;\n  }\n}\n\n/**\n * @desc Get the current handle position for a given color\n * @param props - slider props\n * @param color\n */\nexport function getSliderHandlePosition(props: Partial<SliderOptions>, color: IroColor) {\n  const { width, height, handleRange, handleStart } = getSliderDimensions(props);\n  const ishorizontal = props.layoutDirection === 'horizontal';\n  const sliderValue = getCurrentSliderValue(props, color);\n  const midPoint = ishorizontal ? width / 2 : height / 2;\n  let handlePos = handleStart + (sliderValue / 100) * handleRange;\n  if (ishorizontal) {\n    handlePos = -1 * handlePos + handleRange + handleStart * 2;\n  } \n  return {\n    x: ishorizontal ? midPoint : handlePos, \n    y: ishorizontal ? handlePos : midPoint\n  };\n}\n\n/**\n * @desc Get the gradient stops for a slider\n * @param props - slider props\n * @param color\n */\nexport function getSliderGradient(props: Partial<SliderOptions>, color: IroColor): CssGradientStops {\n  const hsv = color.hsv;\n  const rgb = color.rgb;\n\n  switch (props.sliderType) {\n    case 'red':\n      return [\n        [0, `rgb(${ 0 },${ rgb.g },${ rgb.b })`],\n        [100, `rgb(${ 255 },${ rgb.g },${ rgb.b })`],\n      ];\n    case 'green':\n      return [\n        [0, `rgb(${ rgb.r },${ 0 },${ rgb.b })`],\n        [100, `rgb(${ rgb.r },${ 255 },${ rgb.b })`],\n      ];\n    case 'blue':\n      return [\n        [0, `rgb(${ rgb.r },${ rgb.g },${ 0 })`],\n        [100, `rgb(${ rgb.r },${ rgb.g },${ 255 })`],\n      ];\n    case 'alpha':\n      return [\n        [0, `rgba(${ rgb.r },${ rgb.g },${ rgb.b },0)`],\n        [100, `rgb(${ rgb.r },${ rgb.g },${ rgb.b })`],\n      ];\n    case 'kelvin':\n      const stops = [];\n      const min = props.minTemperature;\n      const max = props.maxTemperature;\n      const numStops = 8;\n      const range = max - min;\n      for (let kelvin = min, stop = 0; kelvin < max; kelvin += range / numStops, stop += 1) {\n        const { r, g, b } = IroColor.kelvinToRgb(kelvin);\n        stops.push([ 100 / numStops * stop, `rgb(${r},${g},${b})` ]);\n      }\n      return stops;\n    case 'hue':\n      return [\n        [0,      '#f00'],\n        [16.666, '#ff0'],\n        [33.333, '#0f0'],\n        [50,     '#0ff'],\n        [66.666, '#00f'],\n        [83.333, '#f0f'],\n        [100,    '#f00'],\n      ];\n    case 'saturation':\n      const noSat = IroColor.hsvToHsl({h: hsv.h, s: 0, v: hsv.v});\n      const fullSat = IroColor.hsvToHsl({h: hsv.h, s: 100, v: hsv.v});\n      return [\n        [0, `hsl(${noSat.h},${noSat.s}%,${noSat.l}%)`],\n        [100, `hsl(${fullSat.h},${fullSat.s}%,${fullSat.l}%)`]\n      ];\n    case 'value':\n    default:\n      const hsl = IroColor.hsvToHsl({h: hsv.h, s: hsv.s, v: 100});\n      return [\n        [0, '#000'],\n        [100, `hsl(${hsl.h},${hsl.s}%,${hsl.l}%)`]\n      ];\n  }\n}\n\n/**\n * @desc Get the gradient coords for a slider\n * @param props - slider props\n */\nexport function getSliderGradientCoords(props: Partial<SliderOptions>) {\n  const ishorizontal = props.layoutDirection === 'horizontal';\n  return {\n    x1: '0%',\n    y1: ishorizontal ? '100%' : '0%',\n    x2: ishorizontal ? '0%' : '100%',\n    y2: '0%'\n  }\n}","import { IroColorPickerOptions } from './colorPickerOptions';\nimport { IroColor, IroColorValue } from './color';\n\nexport interface WheelProps extends IroColorPickerOptions {\n  color: IroColor;\n}\n\nconst TAU = Math.PI * 2;\n\n// javascript's modulo operator doesn't produce positive numbers with negative input\n// https://dev.to/maurobringolf/a-neat-trick-to-compute-modulo-of-negative-numbers-111e\nconst mod = (a: number, n: number) => (a % n + n) % n;\n\n// distance between points (x, y) and (0, 0)\nconst dist = (x: number, y: number) => Math.sqrt(x * x + y * y);\n\n/**\n * @param props - wheel props\n * @internal\n */\nfunction getHandleRange(props: Partial<WheelProps>) {\n  return props.width / 2 - props.padding - props.handleRadius - props.borderWidth;\n}\n\n/**\n * Returns true if point (x, y) lands inside the wheel\n * @param props - wheel props\n * @param x \n * @param y \n */\nexport function isInputInsideWheel(props: Partial<WheelProps>, x: number, y: number) {\n  const { cx, cy } = getWheelDimensions(props);\n  const r = props.width / 2;\n  return dist(cx - x, cy - y) < r;\n}\n\n/**\n * @desc Get the point as the center of the wheel\n * @param props - wheel props\n */\nexport function getWheelDimensions(props: Partial<WheelProps>) {\n  const r = props.width / 2;\n  return {\n    width: props.width,\n    radius: r - props.borderWidth,\n    cx: r,\n    cy: r\n  };\n}\n\n/**\n * @desc Translate an angle according to wheelAngle and wheelDirection\n * @param props - wheel props\n * @param angle - input angle\n */\nexport function translateWheelAngle(props: Partial<WheelProps>, angle: number, invert?: boolean) {\n  const wheelAngle = props.wheelAngle;\n  const wheelDirection = props.wheelDirection\n  // inverted and clockwisee\n  if (invert && wheelDirection === 'clockwise')\n    angle = wheelAngle + angle;\n  // clockwise (input handling)\n  else if (wheelDirection === 'clockwise')\n    angle = (360 - wheelAngle) + angle;\n  // inverted and anticlockwise\n  else if (invert && wheelDirection === 'anticlockwise')\n    angle = (wheelAngle + 180) - angle;\n  // anticlockwise (input handling)\n  else if (wheelDirection === 'anticlockwise')\n    angle = wheelAngle - angle;\n  return mod(angle, 360);\n}\n\n/**\n * @desc Get the current handle position for a given color\n * @param props - wheel props\n * @param color\n */\nexport function getWheelHandlePosition(props: Partial<WheelProps>, color: IroColor) {\n  const hsv = color.hsv;\n  const { cx, cy } = getWheelDimensions(props);\n  const handleRange = getHandleRange(props);\n  const handleAngle = (180 + translateWheelAngle(props, hsv.h, true)) * (TAU / 360);\n  const handleDist = (hsv.s / 100) * handleRange;\n  const direction = props.wheelDirection === 'clockwise' ? -1 : 1;\n  return {\n    x: cx + handleDist * Math.cos(handleAngle) * direction,\n    y: cy + handleDist * Math.sin(handleAngle) * direction,\n  }\n}\n\n/**\n * @desc Get the current wheel value from user input\n * @param props - wheel props\n * @param x - global input x position\n * @param y - global input y position\n */\nexport function getWheelValueFromInput(props: Partial<WheelProps>, x: number, y: number) {\n  const { cx, cy } = getWheelDimensions(props);\n  const handleRange = getHandleRange(props);\n  x = cx - x;\n  y = cy - y;\n  // Calculate the hue by converting the angle to radians\n  const hue = translateWheelAngle(props, Math.atan2(-y, -x) * (360 / TAU));\n  // Find the point's distance from the center of the wheel\n  // This is used to show the saturation level\n  const handleDist = Math.min(dist(x, y), handleRange);\n  return {\n    h: Math.round(hue),\n    s: Math.round((100 / handleRange) * handleDist)\n  };\n}","import { IroColorPickerOptions } from './colorPickerOptions';\n\n// Keep track of html <base> elements for resolveSvgUrl\n// getElementsByTagName returns a live HTMLCollection, which stays in sync with the DOM tree\n// So it only needs to be called once\nlet BASE_ELEMENTS:  HTMLCollectionOf<HTMLBaseElement> | undefined;\n\n/**\n * @desc Resolve an SVG reference URL\n * This is required to work around how Safari and iOS webviews handle gradient URLS under certain conditions\n * If a page is using a client-side routing library which makes use of the HTML <base> tag, \n * Safari won't be able to render SVG gradients properly (as they are referenced by URLs)\n * More info on the problem: \n * https://stackoverflow.com/questions/19742805/angular-and-svg-filters/19753427#19753427\n * https://github.com/jaames/iro.js/issues/18\n * https://github.com/jaames/iro.js/issues/45\n * https://github.com/jaames/iro.js/pull/89\n * @props url - SVG reference URL\n */\nexport function resolveSvgUrl(url: string) {\n  if (!BASE_ELEMENTS)\n    BASE_ELEMENTS = document.getElementsByTagName('base');\n  // Sniff useragent string to check if the user is running Safari\n  const ua = window.navigator.userAgent;\n  const isSafari = /^((?!chrome|android).)*safari/i.test(ua);\n  const isIos = /iPhone|iPod|iPad/i.test(ua);\n  const location = window.location;\n  return ((isSafari || isIos) && (BASE_ELEMENTS.length > 0)) ? `${location.protocol}//${location.host}${location.pathname}${location.search}${url}` : url;\n}\n\n/**\n * @desc Get the path commands to draw an svg arc\n * @props cx - arc center point x\n * @props cy - arc center point y\n * @props radius - arc radius\n * @props startAngle - arc start angle\n * @props endAngle - arc end angle\n */\nexport function getSvgArcPath(cx: number, cy: number, radius: number, startAngle: number, endAngle: number) {\n  const largeArcFlag = endAngle - startAngle <= 180 ? 0 : 1;\n  startAngle *= Math.PI / 180;\n  endAngle *= Math.PI / 180;\n  const x1 = cx + radius * Math.cos(endAngle);\n  const y1 = cy + radius * Math.sin(endAngle);\n  const x2 = cx + radius * Math.cos(startAngle);\n  const y2 = cy + radius * Math.sin(startAngle);\n  return `M ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 0 ${x2} ${y2}`;\n}\n\n/**\n * @desc Given a specifc (x, y) position, test if there's a handle there and return its index, else return null.\n *       This is used for components like the box and wheel which support multiple handles when multicolor is active\n * @props x - point x position\n * @props y - point y position\n * @props handlePositions - array of {x, y} coords for each handle\n */\nexport function getHandleAtPoint(props: Partial<IroColorPickerOptions>, x: number, y: number, handlePositions: {x: number, y: number}[]) {\n  for (let i = 0; i < handlePositions.length; i++) {\n    const dX = handlePositions[i].x - x;\n    const dY = handlePositions[i].y - y;\n    const dist = Math.sqrt(dX * dX + dY * dY);\n    if (dist < props.handleRadius) {\n      return i;\n    }\n  }\n  return null;\n}","import { IroColorPickerOptions } from './colorPickerOptions';\nimport { IroColor, IroColorValue } from './color';\n\nexport interface TriangleWheelProps extends IroColorPickerOptions {\n  color: IroColor;\n  trianglePoints: {\n    x: number;\n    y: number;\n  }[];\n}\n\n/**\n * @desc Get the point as the center of the wheel\n * @param props - wheel props\n */\nexport function getTriangleWheelDimensions(props: Partial<TriangleWheelProps>) {\n  const rad = props.width / 2;\n  const triangleR = rad * 7/8;\n  const triangleH = triangleR * 3/2;\n  const triangleA = triangleR * 3/Math.sqrt(3)\n\n\n  return {\n    width: props.width,\n    radius: rad - props.borderWidth,\n    trianglePoints: [\n      {\n        x: rad,\n        y: rad/8\n      },\n      {\n        x: rad - triangleA/2,\n        y: rad/8 + triangleH,\n      },\n      {\n        x: rad + triangleA/2,\n        y: rad/8 + triangleH,\n      }\n    ],\n    cx: rad,\n    cy: rad\n  };\n}\n\n/**\n * @desc Translate an angle according to wheelAngle and wheelDirection\n * @param props - wheel props\n * @param angle - input angle\n */\nexport function translateTriangleWheelAngle(props: Partial<TriangleWheelProps>, angle: number, invert?: boolean) {\n  const wheelAngle = props.wheelAngle;\n  const wheelDirection = props.wheelDirection\n  if ((!invert && wheelDirection === 'clockwise') || (invert && wheelDirection === 'anticlockwise')) {\n    angle = (invert ? 180 : 360) - (wheelAngle - angle);\n  } \n  else {\n    angle = wheelAngle + angle;\n  }\n  // javascript's modulo operator doesn't produce positive numbers with negative input\n  // https://dev.to/maurobringolf/a-neat-trick-to-compute-modulo-of-negative-numbers-111e\n  return (angle % 360 + 360) % 360;\n}\n\n/**\n * @desc Get the current handle position for a given color\n * @param props - wheel props\n * @param color\n */\nexport function getTriangleWheelHandlePosition(props: Partial<TriangleWheelProps>, color: IroColor) {\n  const hsv = color.hsv;\n  const { radius, cx, cy } = getTriangleWheelDimensions(props);\n  const handleRange = props.width / 2 - props.padding - props.handleRadius - props.borderWidth;\n  const handleAngle = (180 + translateTriangleWheelAngle(props, hsv.h, true)) * (Math.PI / 180);\n  //const handleDist = (hsv.s / 100) * handleRange;\n  const direction = props.wheelDirection === 'clockwise' ? -1 : 1;\n  return {\n    x: cx + (radius - props.padding) * Math.cos(handleAngle) * direction,\n    y: cy + (radius - props.padding) * Math.sin(handleAngle) * direction,\n  }\n}\n\n/**\n * @desc Get the current wheel value from user input\n * @param props - wheel props\n * @param x - global input x position\n * @param y - global input y position\n */\nexport function getTriangleWheelValueFromInput(props: Partial<TriangleWheelProps>, x: number, y: number) {\n  const { cx, cy } = getTriangleWheelDimensions(props);\n  x = cx - x;\n  y = cy - y;\n  // Calculate the hue by converting the angle to radians\n  const hue = translateTriangleWheelAngle(props, Math.atan2(-y, -x) * (180 / Math.PI));\n\n  return {\n    h: Math.round(hue)\n  };\n}","import { IroColorPickerOptions } from './colorPickerOptions';\nimport { IroColor, IroColorValue } from './color';\n\nexport interface HueRingProps extends IroColorPickerOptions {\n  color: IroColor;\n  ringWidth: number\n}\n\n/**\n * @desc Get the point as the center of the ring\n * @param props - ring props\n */\nexport function getHueRingDimensions(props: Partial<HueRingProps>) {\n  const rad = props.width / 2;\n  const radius = rad - props.borderWidth\n\n  return {\n    width: props.width,\n    radius: radius,\n    ringWidth: props.ringWidth || (props.padding + props.handleRadius + props.borderWidth) * 2,\n    cx: rad,\n    cy: rad,\n    borderWidth: props.borderWidth\n  };\n}\n\n/**\n * @desc Translate an angle according to wheelAngle and wheelDirection\n * @param props - wheel props\n * @param angle - input angle\n */\nexport function translateHueRingAngle(props: Partial<HueRingProps>, angle: number, invert?: boolean) {\n  const wheelAngle = props.wheelAngle;\n  const wheelDirection = props.wheelDirection\n  if ((!invert && wheelDirection === 'clockwise') || (invert && wheelDirection === 'anticlockwise')) {\n    angle = (invert ? 180 : 360) - (wheelAngle - angle);\n  } \n  else {\n    angle = wheelAngle + angle;\n  }\n  // javascript's modulo operator doesn't produce positive numbers with negative input\n  // https://dev.to/maurobringolf/a-neat-trick-to-compute-modulo-of-negative-numbers-111e\n  return (angle % 360 + 360) % 360;\n}\n\n/**\n * @desc Get the current handle position for a given color\n * @param props - wheel props\n * @param color\n */\nexport function getHueRingHandlePosition(props: Partial<HueRingProps>, color: IroColor) {\n  const hsv = color.hsv;\n  const { radius, cx, cy } = getHueRingDimensions(props);\n  const handleAngle = (180 + translateHueRingAngle(props, hsv.h, true)) * (Math.PI / 180);\n  const direction = props.wheelDirection === 'clockwise' ? -1 : 1;\n  const ringWidth = props.ringWidth ? props.ringWidth : (props.padding + props.handleRadius + props.borderWidth) * 2;\n  return {\n    x: cx + (radius - ringWidth/2) * Math.cos(handleAngle) * direction,\n    y: cy + (radius - ringWidth/2) * Math.sin(handleAngle) * direction,\n  }\n}\n\n/**\n * @desc Get the current wheel value from user input\n * @param props - wheel props\n * @param x - global input x position\n * @param y - global input y position\n */\nexport function getHueRingValueFromInput(props: Partial<HueRingProps>, x: number, y: number) {\n  const { cx, cy } = getHueRingDimensions(props);\n  x = cx - x;\n  y = cy - y;\n  // Calculate the hue by converting the angle to radians\n  const hue = translateHueRingAngle(props, Math.atan2(-y, -x) * (180 / Math.PI));\n\n  return {\n    h: Math.round(hue)\n  };\n}","import { IroColorPickerOptions } from './colorPickerOptions';\nimport { IroColor, IroColorValue } from './color';\nimport {getWheelDimensions, translateWheelAngle} from \"./wheel\";\n\nexport interface TriangleProps extends IroColorPickerOptions {\n  color: IroColor;\n  trianglePoints: {\n    x: number;\n    y: number;\n  }[];\n  rotation?: number;\n}\n\n/**\n * @desc Get the point as the center of the wheel\n * @param props - wheel props\n */\nexport function getTriangleDimensions(props: Partial<TriangleProps>) {\n  const rad = props.width / 2;\n  const height = (props.width * Math.sqrt(3))/2;\n\n\n  return {\n    width: props.width,\n    height: height,\n    radius: rad - props.borderWidth,\n    trianglePoints: [\n      {\n        x: props.width/2,\n        y: 0\n      },\n      {\n        x: 0,\n        y: height,\n      },\n      {\n        x: props.width,\n        y: height,\n      }\n    ],\n    cx: rad,\n    cy: rad,\n    borderWidth: props.borderWidth\n  };\n}\n\n/**\n * @desc Translate an angle according to wheelAngle and wheelDirection\n * @param props - wheel props\n * @param angle - input angle\n */\nexport function translateTriangleAngle(props: Partial<TriangleProps>, angle: number, invert?: boolean) {\n  const wheelAngle = props.wheelAngle;\n  const wheelDirection = props.wheelDirection\n  if ((!invert && wheelDirection === 'clockwise') || (invert && wheelDirection === 'anticlockwise')) {\n    angle = (invert ? 180 : 360) - (wheelAngle - angle);\n  } \n  else {\n    angle = wheelAngle + angle;\n  }\n  // javascript's modulo operator doesn't produce positive numbers with negative input\n  // https://dev.to/maurobringolf/a-neat-trick-to-compute-modulo-of-negative-numbers-111e\n  return (angle % 360 + 360) % 360;\n}\n\n/**\n * @desc Get the current handle position for a given color\n * @param props - wheel props\n * @param color\n */\nexport function getTriangleHandlePosition(props: Partial<TriangleProps>, color: IroColor) {\n  const hsv = color.hsv;\n  const { height, width } = getTriangleDimensions(props);\n  const handleAngleDeg = (180 + translateTriangleAngle(props, hsv.h, true));\n\n  return {\n    x: width * (1 + (hsv.v * (hsv.s - 200))/20000),\n    y: height * (1 - hsv.s * hsv.v/10000),\n  }\n\n}\n\n/**\n * @desc Get the current wheel value from user input\n * @param props - wheel props\n * @param x - global input x position\n * @param y - global input y position\n */\nexport function getTriangleValueFromInput(props: Partial<TriangleProps>, x: number, y: number) {\n  const { width, height, cx, cy } = getTriangleDimensions(props);\n\n  const rotation = props.rotation ? props.rotation * Math.PI/180 : 0;\n\n  let s: number;\n  let v: number;\n\n  let newX = x;\n  let newY = y;\n\n  if (props.rotation) {\n    const sin = Math.sin(-1 * rotation)\n    const cos = Math.cos(-1 * rotation)\n\n    const xc = x - cx - (sin * cos * 15)\n    const yc = y - cy - (sin * cos * 15)\n\n    newX = xc * cos - yc * sin\n    newY = xc * sin + yc * cos\n\n    newX += cx\n    newY += cy\n\n  }\n\n  s = (200 * width * (height - newY))/((3 * height * width) - (2 * height * newX) - width * newY);\n  v = 50 * (3 - (newY/height) - (2 * newX/width));\n\n  return {\n    s: Math.min(100, Math.max( 0, Math.round(s))),\n    v: Math.min(100, Math.max( 0, Math.round(v)))\n  };\n}\n\n/**\n * @desc Get the gradient stops for a triangle\n * @param props - box props\n * @param color\n */\nexport function getTriangleGradients(props: Partial<TriangleProps>, color: IroColor) {\n  const hue = color.hue;\n  return [\n    // saturation gradient\n    [\n      [0, '#fff'],\n      [100, `hsl(${hue},100%,50%)`],\n    ],\n    // lightness gradient\n    [\n      [0, 'rgba(0,0,0,0)'],\n      [100, '#000'],\n    ]\n  ];\n}","import { IroColor } from './color';\nimport { CssGradientStops } from './css';\nimport { IroColorPickerOptions } from './colorPickerOptions';\n\nexport interface BoxOptions extends IroColorPickerOptions {\n  color: IroColor;\n}\n\n/**\n * @desc Get the CSS styles for the box root element\n * @param props - box props\n */\nexport function getBoxStyles(props: Partial<BoxOptions>) {\n  return {\n    [props.layoutDirection === 'horizontal' ? 'marginLeft' : 'marginTop']: props.sliderMargin\n  }\n}\n\n/**\n * @desc Get the bounding dimensions of the box\n * @param props - box props\n */\nexport function getBoxDimensions(props: Partial<BoxOptions>) {\n  const { width, boxHeight, padding, handleRadius } = props;\n  return {\n    width: width,\n    height: boxHeight ?? width,\n    radius: padding + handleRadius\n  };\n}\n\n/**\n * @desc Get the current box value from user input\n * @param props - box props\n * @param x - global input x position\n * @param y - global input y position\n */\nexport function getBoxValueFromInput(props: Partial<BoxOptions>, x: number, y: number) {\n  const { width, height, radius } = getBoxDimensions(props);\n  const handleStart = radius;\n  const handleRangeX = width - radius * 2;\n  const handleRangeY = height - radius * 2;\n  const percentX = ((x - handleStart) / handleRangeX) * 100;\n  const percentY = ((y - handleStart) / handleRangeY) * 100;\n  return {\n    s: Math.max(0, Math.min(percentX, 100)),\n    v: Math.max(0, Math.min(100 - percentY, 100))\n  }\n}\n\n/**\n * @desc Get the current box handle position for a given color\n * @param props - box props\n * @param color\n */\nexport function getBoxHandlePosition(props: Partial<BoxOptions>, color: IroColor) {\n  const { width, height, radius } = getBoxDimensions(props);\n  const hsv = color.hsv;\n  const handleStart = radius;\n  const handleRangeX = width - radius * 2;\n  const handleRangeY = height - radius * 2;\n  return { \n    x: handleStart + (hsv.s / 100) * handleRangeX,\n    y: handleStart + (handleRangeY - ((hsv.v / 100) * handleRangeY))\n  }\n}\n\n/**\n * @desc Get the gradient stops for a box\n * @param props - box props\n * @param color\n */\nexport function getBoxGradients(props: Partial<BoxOptions>, color: IroColor): CssGradientStops[] {\n  const hue = color.hue;\n  return [\n    // saturation gradient\n    [\n      [0, '#fff'],\n      [100, `hsl(${hue},100%,50%)`],\n    ],\n    // lightness gradient\n    [\n      [0, 'rgba(0,0,0,0)'],\n      [100, '#000'],\n    ]\n  ];\n}","import { IroColorPickerOptions } from './colorPickerOptions';\n\nexport function cssBorderStyles(props: IroColorPickerOptions) {\n  return {\n    boxSizing: 'border-box',\n    border: `${ props.borderWidth }px solid ${ props.borderColor }`\n  };\n}\n\nexport type CssGradientType = 'linear' | 'radial' | 'conical';\nexport type CssGradientStops = [number, number | string][];\n\nexport function cssGradient(type: CssGradientType, direction: string, stops: CssGradientStops) {\n  return `${ type }-gradient(${ direction }, ${ stops.map(([o, col]) => `${ col } ${ o }%`).join(',') })`;\n}\n\nexport function cssValue(value: number | string) {\n  if (typeof(value) === 'string')\n    return value;\n  return `${ value }px`;\n}","import { IroColor, IroColorValue } from './color';\n\nexport type LayoutDirection = 'vertical' | 'horizontal' | '';\n\nexport type WheelDirection = 'clockwise' | 'anticlockwise' | '';\n\nexport interface IroColorPickerOptions {\n  width?: number;\n  height?: number;\n  color?: IroColorValue;\n  colors?: IroColorValue[];\n  padding?: number;\n  layoutDirection?: LayoutDirection;\n  borderColor?: string;\n  borderWidth?: number;\n  handleRadius?: number;\n  activeHandleRadius?: number;\n  handleSvg?: string;\n  handleProps?: any;\n  wheelLightness?: boolean;\n  wheelAngle?: number;\n  wheelDirection?: WheelDirection;\n  sliderSize?: number;\n  sliderMargin?: number;\n  boxHeight?: number;\n}\n\nexport const iroColorPickerOptionDefaults: IroColorPickerOptions = {\n  width: 300,\n  height: 300,\n  color: '#fff',\n  colors: [],\n  padding: 6,\n  layoutDirection: 'vertical',\n  borderColor: '#fff',\n  borderWidth: 0,\n  handleRadius: 8,\n  activeHandleRadius: null,\n  handleSvg: null,\n  handleProps: {x: 0, y: 0},\n  wheelLightness: true,\n  wheelAngle: 0,\n  wheelDirection: 'anticlockwise',\n  sliderSize: null,\n  sliderMargin: 12,\n  boxHeight: null\n}"],"names":["CSS_UNIT","PERMISSIVE_MATCH_3","PERMISSIVE_MATCH_4","REGEX_FUNCTIONAL_RGB","RegExp","REGEX_FUNCTIONAL_RGBA","REGEX_FUNCTIONAL_HSL","REGEX_FUNCTIONAL_HSLA","REGEX_HEX_3","HEX_START","REGEX_HEX_4","REGEX_HEX_6","REGEX_HEX_8","log","Math","round","floor","clamp","num","min","max","parseUnit","str","isPercentage","indexOf","parseFloat","parseHexInt","parseInt","intToHex","int","toString","padStart","IroColor","value","onChange","this","$","h","s","v","a","set","initialValue","test","hexString","rgbString","hslString","Error","hsv","rgb","hsl","kelvin","setChannel","format","channel","reset","hsva","clone","unbind","undefined","hsvToRgb","i","f","p","q","t","mod","g","b","r","rgbToHsv","delta","hue","saturation","hsvToHsl","l","divisor","hslToHsv","kelvinToRgb","temp","rgbToKelvin","minTemp","maxTemp","newValue","oldValue","changes","key","alpha","match","exec","rgba","hsla","getSliderDimensions","props","width","sliderSize","handleRadius","padding","ishorizontal","layoutDirection","sliderShape","handleStart","handleRange","height","cx","cy","radius","borderWidth","x","y","getCurrentSliderValue","color","sliderType","minTemperature","maxTemperature","BASE_ELEMENTS","TAU","PI","dist","sqrt","getHandleRange","getWheelDimensions","translateWheelAngle","angle","invert","wheelAngle","wheelDirection","getTriangleWheelDimensions","rad","triangleR","triangleH","triangleA","trianglePoints","translateTriangleWheelAngle","getHueRingDimensions","ringWidth","translateHueRingAngle","getTriangleDimensions","translateTriangleAngle","getBoxDimensions","boxHeight","boxSizing","border","borderColor","type","direction","stops","map","join","handleRangeY","sliderMargin","percentY","handlePositions","length","dX","dY","handleAngle","cos","sin","atan2","range","stop","push","noSat","fullSat","x1","y1","x2","y2","midPoint","handlePos","percent","startAngle","endAngle","largeArcFlag","rotation","newX","newY","xc","yc","handleDist","colors","activeHandleRadius","handleSvg","handleProps","wheelLightness","url","document","getElementsByTagName","ua","window","navigator","userAgent","isSafari","isIos","location","protocol","host","pathname","search"],"mappings":"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"}